<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/estilo.css">
    <link rel="stylesheet" href="css/prism.css">

    <title>APIs e Microsservi√ßos - Aula 06 - Testes e Refatora√ß√£o</title>
</head>

<body>
    <div class="wrapper d-flex align-items-stretch">
        <nav id="sidebar">
            <div class="custom-menu">
                <button type="button" id="sidebarCollapse" class="btn btn-primary">
                    <i class="fa fa-bars"></i>
                    <span class="sr-only">Toggle Menu</span>
                </button>
            </div>
            <h1><a href="index.html" class="logo text-center">AULAS</a></h1>
            <ul class="list-unstyled components mb-5">
                <li>
                    <a href="Aula01.html"><span class="mr-1"></span>01 - Revis√£o</a>
                </li>
                <li>
                    <a href="Aula02.html"><span class="mr-0"></span>02 - Revis√£o II</a>
                </li>
                <li>
                    <a href="Aula03.html"><span class="mr-0"></span>03 - REST I</a>
                </li>
                <li>
                    <a href="Aula04.html"><span class="mr-0"></span>04 - REST II</a>
                </li>
                <li>
                    <a href="Aula05.html"><span class="mr-0"></span>05 - REST III</a>
                </li>
                <li class="active">
                    <a href="Aula06.html"><span class="mr-0"></span>06 - REST IV</a>
                </li>
                <li>
                    <a href="Aula07.html"><span class="mr-0"></span>07 - Exerc√≠cio I</a>
                </li>
                <li>
                    <a href="Aula08.html"><span class="mr-0"></span>08 - REST V</a>
                </li>
                <li>
                    <a href="Aula09.html"><span class="mr-0"></span>09 - Microsservi√ßos I</a>
                </li>
                <li>
                    <a href="Aula10.html"><span class="mr-0"></span>10 - Microsservi√ßos II</a>
                </li>
                <li>
                    <a href="Aula11.html"><span class="mr-0"></span>11 - Microsservi√ßos III</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>12 - Microsservi√ßos IV</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>13 - Microsservi√ßos V</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>14 - Microsservi√ßos VI</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>15 - Microsservi√ßos VII</a>
                </li>
            </ul>
        </nav>

        <div id="content" class="p-4 p-md-5 pt-5">

            <h1>Aula 06 ‚Äì Refatora√ß√£o dos Controllers, camada de servi√ßo e Introdu√ß√£o aos Testes Automatizados</h1>
            <p>Na Aula 05, estruturamos nossa API com uso de DTOs, paginamos os endpoints, substitu√≠mos o banco em
                mem√≥ria por um banco relacional real e documentamos todos os nossos recursos com Swagger. Agora,
                avan√ßaremos um passo al√©m na maturidade da nossa aplica√ß√£o: vamos realizar uma <strong>refatora√ß√£o
                    completa dos nossos controllers</strong>, otimizar o uso do <code>ModelMapper</code> para reduzir
                mapeamentos manuais, separar a l√≥gica da controller na camada de servi√ßo e, ainda, iniciaremos a
                <strong>introdu√ß√£o aos testes automatizados</strong> da aplica√ß√£o.</p>
            <p>Como sempre, seguiremos um processo pr√°tico dando in√≠cio de onde paramos na aula anterior: nosso
                exerc√≠cio pedia. Come√ßaremos com a <strong>refatora√ß√£o dos endpoints</strong>, adotando o padr√£o
                <code>ResponseEntity</code> ‚Äî um dos mais recomendados para retornos HTTP em APIs Spring Boot.</p>
            <hr>
            <h2>1. Refatorando nossos Controllers com <code>ResponseEntity</code></h2>
            <p>At√© aqui, utilizamos retornos diretos como <code>ContactResponseDTO</code> ou
                <code>Page&lt;ContactResponseDTO&gt;</code> nos m√©todos de nossos controllers. Embora essa abordagem
                funcione bem, ela <strong>n√£o oferece controle detalhado sobre o que est√° sendo retornado na resposta
                    HTTP</strong>, como cabe√ßalhos, status espec√≠ficos ou metadados adicionais - para isso precisamos
                usar anota√ß√µes como <code>@ResponseStatus(HttpStatus.OK)</code> e outros artif√≠cios de implementa√ß√£o.
            </p>
            <p>O uso da classe <code>ResponseEntity&lt;T&gt;</code> resolve essa limita√ß√£o, fornecendo uma interface
                simplificada para uso. Essa classe encapsula:</p>
            <ul>
                <li>o <strong>corpo da resposta</strong> (um DTO, por exemplo),</li>
                <li>o <strong>status HTTP</strong> (200 OK, 201 Created, 204 No Content, 404 Not Found, etc),</li>
                <li>e opcionalmente <strong>cabe√ßalhos adicionais</strong>.</li>
            </ul>
            <h3>1.1 Por que usar <code>ResponseEntity</code>?</h3>
            <p>Adotar o <code>ResponseEntity</code> proporciona mais <strong>clareza, flexibilidade e ader√™ncia aos
                    padr√µes HTTP</strong>, al√©m de preparar a aplica√ß√£o para requisitos mais avan√ßados, como:</p>
            <ul>
                <li>inclus√£o de cabe√ßalhos de autentica√ß√£o ou cache,</li>
                <li>retorno de localiza√ß√µes (<code>Location</code>) ap√≥s cria√ß√£o de recursos,</li>
                <li>respostas com conte√∫dos customizados ou sem corpo (<code>204 No Content</code>),</li>
                <li>e suporte facilitado a testes e a respostas espec√≠ficas em diferentes cen√°rios.</li>
            </ul>
            <p>Al√©m disso, ele torna expl√≠cito para quem l√™ o c√≥digo qual √© o status retornado pela requisi√ß√£o, o que
                melhora a manuten√ß√£o e a legibilidade da aplica√ß√£o, sendo o uso de <code>ResponseEntity</code> a
                implementa√ß√£o preferida pela comunidade Spring.</p>
            <h3>‚ú® Vantagens do uso de <code>ResponseEntity</code></h3>
            <table>
                <thead>
                    <tr>
                        <th>Recurso</th>
                        <th>Benef√≠cio</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Controle expl√≠cito do status</td>
                        <td>Podemos retornar 200, 201, 204, 400, 404, 500, etc.</td>
                    </tr>
                    <tr>
                        <td>Headers customizados</td>
                        <td>Podemos adicionar cabe√ßalhos HTTP (como <code>Location</code>)</td>
                    </tr>
                    <tr>
                        <td>Corpo da resposta opcional</td>
                        <td>Podemos retornar apenas status, sem corpo (<code>noContent()</code>)</td>
                    </tr>
                    <tr>
                        <td>Adequa√ß√£o a testes e versionamento</td>
                        <td>Facilita asser√ß√µes em testes e torna o contrato mais claro</td>
                    </tr>
                </tbody>
            </table>
            <h3>1.2 Sintaxe b√°sica de <code>ResponseEntity</code></h3>
            <p>O <code>ResponseEntity</code> possui uma forma mais verbosa de uso, como mostrado abaixo</p>
            <pre><code class="language-java">return ResponseEntity
        .status(HttpStatus.CREATED)
        .body(contactResponseDTO); 
</code></pre>
            <p>E uma forma mais enxuta com m√©todos auxiliares:</p>
            <pre><code class="language-java">return ResponseEntity.ok(dto); // 200 OK com corpo
return ResponseEntity.noContent().build(); // 204 No Content
</code></pre>
            <h3>1.3 Refatorando um exemplo de endpoint</h3>
            <p>Antes da refatora√ß√£o:</p>
            <pre><code class="language-java">@DeleteMapping(&quot;/{id}&quot;)
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteContact(@PathVariable Long id) {
    contactRepository.deleteById(id);
}
</code></pre>
            <p>Ap√≥s refatora√ß√£o:</p>
            <pre><code class="language-java">@DeleteMapping(&quot;/{id}&quot;)
public ResponseEntity&lt;Void&gt; deleteContact(@PathVariable Long id) {
    if (!contactRepository.existsById(id)) {
        throw new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id);
    }
    contactRepository.deleteById(id);
    return ResponseEntity.noContent().build();
}
</code></pre>
            <p>Observe que com <code>ResponseEntity</code> ganhamos <strong>clareza sem√¢ntica</strong>. Al√©m disso,
                adicionamos a cl√°usula de verifica√ß√£o para checar se o id passado como argumento existe em nossa base de
                dados, j√° que por algum motivo desconhecido havia me esquecido de implementar isso anteriormente. ü´†</p>
            <h3>1.4 Padr√£o a ser adotado nos m√©todos</h3>
            <p>A seguir est√£o os padr√µes que iremos aplicar na refatora√ß√£o dos m√©todos da controller:</p>
            <table>
                <thead>
                    <tr>
                        <th>Tipo de opera√ß√£o</th>
                        <th>C√≥digo HTTP</th>
                        <th>Exemplo Spring</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Buscar recurso</td>
                        <td>200 OK</td>
                        <td><code>ResponseEntity.ok(resource)</code></td>
                    </tr>
                    <tr>
                        <td>Criar recurso</td>
                        <td>201 Created</td>
                        <td><code>ResponseEntity.status(CREATED).body(resource)</code></td>
                    </tr>
                    <tr>
                        <td>Atualizar recurso</td>
                        <td>200 OK</td>
                        <td><code>ResponseEntity.ok(resource)</code></td>
                    </tr>
                    <tr>
                        <td>Atualizar parcial</td>
                        <td>200 OK</td>
                        <td><code>ResponseEntity.ok(resource)</code></td>
                    </tr>
                    <tr>
                        <td>Deletar recurso</td>
                        <td>204 NoContent</td>
                        <td><code>ResponseEntity.noContent().build()</code></td>
                    </tr>
                    <tr>
                        <td>Recurso n√£o encontrado</td>
                        <td>404 Not Found</td>
                        <td>Lan√ßar <code>ResourceNotFoundException</code> para ser tratada globalmente</td>
                    </tr>
                </tbody>
            </table>
            <h3>1.5 Refatorando os m√©todos do Controller</h3>
            <p>Al√©m da refatora√ß√£o do endpoint de dele√ß√£o de um contato, vejamos a refatora√ß√£o de mais alguns dos
                m√©todos do <code>ContactController</code> e <code>AddressController</code>, substituindo os retornos
                diretos pelos retornos com <code>ResponseEntity</code>. O objetivo √© tornar os endpoints mais claros e
                preparados para evolu√ß√µes, como headers, cache, redirecionamentos ou altera√ß√µes no corpo da resposta.
            </p>
            <p>Para manter a aula leve e compreens√≠vel, mostraremos alguns m√©todos como exemplo a seguir. A vers√£o final
                de todos os m√©todos ser√° apresentada ao final da se√ß√£o, como fizemos na Aula 05.</p>
            <h3>üß± Exemplo 1: <code>createContact()</code></h3>
            <p>Na aula anterior nosso m√©todo estava da seguinte forma:</p>
            <pre><code class="language-java">@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public ContactResponseDTO createContact(@Valid @RequestBody ContactRequestDTO dto) {
    // Mapeia os campos simples
    Contact contact = new Contact(dto.getNome(), dto.getEmail(), dto.getTelefone());
            
    // Mapeia os endere√ßos manualmente
    var addresses = dto.getAddresses().stream()
        .map(addrDto -&gt; {
            Address address = new Address();
            address.setRua(addrDto.getRua());
            address.setCidade(addrDto.getCidade());
            address.setEstado(addrDto.getEstado());
            address.setCep(addrDto.getCep());
            address.setContact(contact); 
            return address;
        }).toList();
            
    contact.setAddresses(addresses);
            
    Contact saved = contactRepository.save(contact);
    return modelMapper.map(saved, ContactResponseDTO.class);
}
</code></pre>
            <p>Agora, vamos refatorar nosso m√©todo e deix√°-lo como mostrado a seguir:</p>
            <pre><code class="language-java">@PostMapping
public ResponseEntity&lt;ContactResponseDTO&gt; createContact(@Valid @RequestBody ContactRequestDTO dto) {
    Contact contact = modelMapper.map(dto, Contact.class);
    contact.getAddresses().forEach(address -&gt; address.setContact(contact));
    Contact saved = contactRepository.save(contact);
    ContactResponseDTO responseDTO = modelMapper.map(saved, ContactResponseDTO.class);
    return ResponseEntity.status(HttpStatus.CREATED).body(responseDTO);
}
</code></pre>
            <p>No primeiro m√©todo a cria√ß√£o de um novo contato √© realizada de maneira bastante manual. Inicialmente, os
                campos do objeto <code>Contact</code> s√£o populados diretamente a partir dos valores do DTO, utilizando
                um construtor expl√≠cito. Em seguida, os endere√ßos s√£o mapeados um a um atrav√©s de um
                <code>stream</code>, onde cada <code>AddressRequestDTO</code> √© convertido manualmente em uma inst√¢ncia
                da entidade <code>Address</code>. Durante esse processo, tamb√©m √© feita a associa√ß√£o entre cada endere√ßo
                e o contato rec√©m-criado, garantindo o v√≠nculo bidirecional necess√°rio para persist√™ncia correta com
                JPA. Ap√≥s o mapeamento, a lista de endere√ßos √© atribu√≠da ao contato e, por fim, o contato √© salvo no
                banco e convertido em um <code>ContactResponseDTO</code> utilizando o <code>ModelMapper</code>.</p>
            <p>Essa abordagem, embora funcional, gera um ac√∫mulo de responsabilidades no controller e uma repeti√ß√£o
                consider√°vel de c√≥digo, o que pode dificultar a manuten√ß√£o √† medida que a aplica√ß√£o cresce.</p>
            <p>J√° o segundo m√©todo apresenta uma vers√£o mais enxuta e elegante da mesma funcionalidade. Nessa vers√£o
                refatorada, o <code>ModelMapper</code> √© utilizado diretamente para mapear o
                <code>ContactRequestDTO</code> para a entidade <code>Contact</code>, eliminando a necessidade de
                instanciar o objeto manualmente e escrever c√≥digo repetitivo para setar os atributos. O √∫nico passo que
                permanece manual √© a associa√ß√£o entre os endere√ßos e o contato ‚Äî e isso √© feito de forma simples e
                clara, com um <code>forEach</code>. Ap√≥s o salvamento da entidade no banco, o resultado √© novamente
                convertido para o DTO de resposta com o <code>ModelMapper</code>.</p>
            <p>Outro ponto de melhoria √© o uso do <code>ResponseEntity</code> para retornar a resposta da API. Com isso,
                temos controle expl√≠cito sobre o status HTTP (201 Created), o que torna a resposta mais alinhada √†s
                pr√°ticas RESTful e facilita o envio de cabe√ßalhos adicionais, se necess√°rio.</p>
            <p>Essa refatora√ß√£o traz diversos benef√≠cios: o c√≥digo fica mais limpo, a responsabilidade de convers√£o
                entre DTOs e entidades √© centralizada no <code>ModelMapper</code>, e o controller passa a ser
                respons√°vel apenas por orquestrar as chamadas ‚Äî o que √© exatamente seu papel. Al√©m disso, a nova vers√£o
                favorece a legibilidade, testabilidade e manuten√ß√£o do c√≥digo, caracter√≠sticas essenciais em projetos
                profissionais e de m√©dio a longo prazo.</p>
            <p>Uma melhoria posterior seria a implementa√ß√£o de uma camada de servi√ßo, por meio da extra√ß√£o da l√≥gica e
                simplifica√ß√£o ainda maior do nosso Controller. Abordaremos esse padr√£o organizacional posteriormente na
                aula.</p>
            <h3>üß± Exemplo 2: <code>getAllContacts()</code></h3>
            <p>Na aula anterior nosso m√©todo estava da seguinte forma:</p>
            <pre><code class="language-java">@GetMapping
public Page&lt;ContactResponseDTO&gt; getAllContacts(Pageable pageable) {
    Page&lt;Contact&gt; contacts = contactRepository.findAll(pageable);
    return contacts.map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
}            
</code></pre>
            <p>Agora, vamos refatorar nosso m√©todo e deix√°-lo como mostrado a seguir:</p>
            <pre><code class="language-java">@GetMapping
public ResponseEntity&lt;Page&lt;ContactResponseDTO&gt;&gt; getAllContacts(Pageable pageable) {
    Page&lt;Contact&gt; contacts = contactRepository.findAll(pageable);
    Page&lt;ContactResponseDTO&gt; responseDTO = contacts
        .map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
    return ResponseEntity.ok(responseDTO);
}
</code></pre>
            <p>Como percebem, seguimos a mesma linha de refatora√ß√£o que fizemos anteriormente, ou seja, a diferen√ßa
                entre os dois m√©todos est√° na forma como a resposta √© constru√≠da e retornada para o cliente. Ambos
                realizam a mesma tarefa essencial: recuperar todos os contatos de forma paginada e convert√™-los para um
                Page<ContactResponseDTO>, utilizando o ModelMapper para transformar os objetos da entidade Contact em
                    objetos de transfer√™ncia de dados (DTO). No entanto, a segunda vers√£o aplica uma refatora√ß√£o
                    importante ao envolver o retorno em um ResponseEntity, enquanto a primeira retorna diretamente o
                    Page resultante.</p>
            <p>Na primeira vers√£o a resposta da requisi√ß√£o √© retornada de maneira direta. O Spring Boot, por padr√£o,
                interpreta o tipo de retorno e aplica um status HTTP 200 (OK) automaticamente. Esse estilo √© v√°lido e
                perfeitamente funcional, principalmente em projetos menores ou em endpoints que n√£o exigem
                personaliza√ß√µes adicionais no cabe√ßalho da resposta ou no status. No entanto, essa abordagem oferece
                menos controle sobre o que est√° sendo retornado, j√° que n√£o h√° flexibilidade para modificar status HTTP,
                cabe√ßalhos ou outras configura√ß√µes da resposta de forma expl√≠cita.</p>
            <p>J√° a vers√£o refatorada segue uma pr√°tica mais robusta e alinhada √†s boas pr√°ticas em APIs RESTful:
                utiliza o ResponseEntity, para representar toda a resposta HTTP, incluindo corpo, status e cabe√ßalhos.
                Ao encapsular a resposta em um ResponseEntity.ok(...), o m√©todo deixa claro e expl√≠cito que est√°
                retornando uma resposta com status HTTP 200 (OK), al√©m de permitir, se necess√°rio, o uso de outros
                m√©todos como .status(), .headers(), ou at√© mesmo .noContent() para outros cen√°rios.</p>
            <h3>ü§† Resumo</h3>
            <p>Refatorar os m√©todos do controller para retornar <code>ResponseEntity</code> √© um pequeno ajuste com
                <strong>impacto positivo</strong> na legibilidade, testabilidade e padroniza√ß√£o da API. Essa abordagem
                permite que, futuramente, adicionemos headers, links, status alternativos ou tratamentos especiais sem
                precisar alterar a assinatura do m√©todo.</p>
            <p>Al√©m disso, a documenta√ß√£o gerada pelo Swagger/OpenAPI tamb√©m pode ser enriquecida com status HTTP mais
                precisos e podemos alterar a inje√ß√£o de depend√™ncia que vinhamos usando com <code>@Autowired</code> para
                inje√ß√£o via construtor!</p>
            <p>Vamos implementar essas refatora√ß√µes e rever o nosso c√≥digo completo do controller.</p>
            <hr>
            <h2>2. Refatorando nossos Controllers com <code>ResponseEntity</code></h2>
            <p>Ap√≥s a implementa√ß√£o das refatora√ß√µes mencionadas acima (<code>ResponseEntity</code>, melhoria na
                documenta√ß√£o Swagger, inje√ß√£o de depend√™ncia via construtor) chegamos √† seguinte implementa√ß√£o do
                Controller.</p>
            <pre><code class="language-java">package br.ifsp.contacts.controller;

@Tag(name = &quot;Contatos&quot;, description = &quot;API para gerenciamento de contatos&quot;)
@Validated
@RestController
@RequestMapping(&quot;/api/contacts&quot;)
public class ContactController {

        private final ContactRepository contactRepository;
        private final ModelMapper modelMapper;

        public ContactController(ContactRepository contactRepository, ModelMapper modelMapper) {
                this.contactRepository = contactRepository;
                this.modelMapper = modelMapper;
        }

        /**
         * Retorna uma lista paginada de todos os contatos.
         * 
         * @param pageable informa√ß√µes de pagina√ß√£o
         * @return p√°gina de contatos
         */
        @Operation(summary = &quot;Listar todos os contatos&quot;, description = &quot;Retorna uma lista paginada de todos os contatos cadastrados no sistema&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contatos encontrados com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @GetMapping
        public ResponseEntity&lt;Page&lt;ContactResponseDTO&gt;&gt; getAllContacts(Pageable pageable) {
                Page&lt;Contact&gt; contacts = contactRepository.findAll(pageable);
                Page&lt;ContactResponseDTO&gt; responseDTO = contacts
                                .map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
                return ResponseEntity.ok(responseDTO);
        }

        /**
         * Busca um contato pelo ID.
         * 
         * @param id identificador do contato
         * @return contato encontrado
         * @throws ResourceNotFoundException se o contato n√£o for encontrado
         */
        @Operation(summary = &quot;Buscar contato por ID&quot;, description = &quot;Retorna um contato espec√≠fico com base no ID fornecido&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato encontrado com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @GetMapping(&quot;/{id}&quot;)
        public ResponseEntity&lt;ContactResponseDTO&gt; getContactById(@PathVariable Long id) {
                Contact contact = contactRepository.findById(id)
                                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

                ContactResponseDTO responseDTO = modelMapper.map(contact, ContactResponseDTO.class);
                return ResponseEntity.ok(responseDTO);
        }

        /**
         * Cria um novo contato.
         * 
         * @param dto dados do contato a ser criado
         * @return contato criado
         */
        @Operation(summary = &quot;Criar novo contato&quot;, description = &quot;Cria um novo contato com os dados fornecidos&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Contato criado com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Dados inv√°lidos&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @PostMapping
        public ResponseEntity&lt;ContactResponseDTO&gt; createContact(@Valid @RequestBody ContactRequestDTO dto) {
                Contact contact = modelMapper.map(dto, Contact.class);
                contact.getAddresses().forEach(address -&gt; address.setContact(contact));
                Contact saved = contactRepository.save(contact);
                ContactResponseDTO responseDTO = modelMapper.map(saved, ContactResponseDTO.class);
                return ResponseEntity.status(HttpStatus.CREATED).body(responseDTO);
        }

        /**
         * Atualiza um contato existente.
         * 
         * @param id  identificador do contato
         * @param dto novos dados do contato
         * @return contato atualizado
         * @throws ResourceNotFoundException se o contato n√£o for encontrado
         */
        @Operation(summary = &quot;Atualizar contato&quot;, description = &quot;Atualiza todos os dados de um contato existente&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato atualizado com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Dados inv√°lidos&quot;),
                        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @PutMapping(&quot;/{id}&quot;)
        public ResponseEntity&lt;ContactResponseDTO&gt; updateContact(@PathVariable Long id,
                        @Valid @RequestBody ContactRequestDTO dto) {
                Contact existingContact = contactRepository.findById(id)
                                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

                modelMapper.map(dto, existingContact);
                existingContact.getAddresses().forEach(address -&gt; address.setContact(existingContact));

                Contact updated = contactRepository.save(existingContact);
                ContactResponseDTO responseDTO = modelMapper.map(updated, ContactResponseDTO.class);
                return ResponseEntity.ok(responseDTO);
        }

        /**
         * Atualiza parcialmente um contato existente.
         * 
         * @param id  identificador do contato
         * @param dto dados a serem atualizados
         * @return contato atualizado
         * @throws ResourceNotFoundException se o contato n√£o for encontrado
         */
        @Operation(summary = &quot;Atualizar contato parcialmente&quot;, description = &quot;Atualiza apenas os campos especificados de um contato existente&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato atualizado com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @PatchMapping(&quot;/{id}&quot;)
        public ResponseEntity&lt;ContactResponseDTO&gt; updateContactPartial(@PathVariable Long id,
                        @RequestBody ContactPatchDTO dto) {
                Contact existingContact = contactRepository.findById(id)
                                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
                dto.getNome().ifPresent(existingContact::setNome);
                dto.getEmail().ifPresent(existingContact::setEmail);
                dto.getTelefone().ifPresent(existingContact::setTelefone);
                Contact saved = contactRepository.save(existingContact);
                ContactResponseDTO responseDTO = modelMapper.map(saved, ContactResponseDTO.class);
                return ResponseEntity.ok(responseDTO);
        }

        /**
         * Exclui um contato.
         * 
         * @param id identificador do contato
         * @return resposta sem conte√∫do
         * @throws ResourceNotFoundException se o contato n√£o for encontrado
         */
        @Operation(summary = &quot;Excluir contato&quot;, description = &quot;Remove permanentemente um contato do sistema&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Contato exclu√≠do com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @DeleteMapping(&quot;/{id}&quot;)
        public ResponseEntity&lt;Void&gt; deleteContact(@PathVariable Long id) {
                if (!contactRepository.existsById(id)) {
                        throw new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id);
                }
                contactRepository.deleteById(id);
                return ResponseEntity.noContent().build();
        }

        /**
         * Busca contatos pelo nome.
         * 
         * @param name     nome ou parte do nome a ser pesquisado
         * @param pageable informa√ß√µes de pagina√ß√£o
         * @return lista paginada de contatos que correspondem ao crit√©rio de busca
         */
        @Operation(summary = &quot;Buscar contatos por nome&quot;, description = &quot;Retorna uma lista paginada de contatos cujo nome cont√©m o termo pesquisado&quot;)
        @ApiResponses(value = {
                        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Busca realizada com sucesso&quot;),
                        @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
        })
        @GetMapping(&quot;/search&quot;)
        public ResponseEntity&lt;Page&lt;ContactResponseDTO&gt;&gt; searchContactsByName(@RequestParam String name,
                        Pageable pageable) {
                Page&lt;Contact&gt; contacts = contactRepository.findByNomeContainingIgnoreCase(name, pageable);
                Page&lt;ContactResponseDTO&gt; responseDTO = contacts
                                .map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
                return ResponseEntity.ok(responseDTO);
        }
}
</code></pre>
            <p>Vamos usar essa oportunidade para relembrar (e refor√ßar) os conceitos que vimos anteriormente. Passemos √†
                an√°lise do nosso c√≥digo, m√©todo a m√©todo!</p>
            <h3>üîé Construtor da classe</h3>
            <p>Nosso construtor ficou da seguinte forma na nova vers√£o.</p>
            <pre><code class="language-java">public ContactController(ContactRepository contactRepository, ModelMapper modelMapper) {
    this.contactRepository = contactRepository;
    this.modelMapper = modelMapper;
}
</code></pre>
            <p>Nessa vers√£o refatorada implementamos a <strong>inje√ß√£o de depend√™ncia via construtor</strong>, que √©
                considerada uma pr√°tica superior √† inje√ß√£o feita diretamente em atributos com <code>@Autowired</code> no
                desenvolvimento com Spring Boot. Isso se deve a diversos motivos t√©cnicos e de boas pr√°ticas que
                promovem c√≥digo mais limpo, seguro, test√°vel e f√°cil de manter.</p>
            <p>Um dos principais benef√≠cios da inje√ß√£o via construtor √© a <strong>possibilidade de declarar os atributos
                    como <code>final</code></strong>, o que garante que essas depend√™ncias nunca ser√£o modificadas ap√≥s
                a inicializa√ß√£o da classe. Isso refor√ßa o princ√≠pio da imutabilidade, contribuindo para a seguran√ßa do
                c√≥digo e reduzindo a possibilidade de exce√ß√µes do tipo <code>NullPointerException</code>.</p>
            <p>Al√©m disso, essa abordagem <strong>facilita os testes unit√°rios</strong>. Ao utilizar construtores, o
                desenvolvedor pode instanciar a classe sob teste passando diretamente objetos mockados ou stubs das
                depend√™ncias, sem depender do contexto do Spring para realizar inje√ß√µes autom√°ticas. Isso torna o c√≥digo
                mais independente, modular e f√°cil de testar em isolamento.</p>
            <p>Outro ponto positivo √© a <strong>clareza e a legibilidade do c√≥digo</strong>. Quando os construtores s√£o
                usados explicitamente, √© f√°cil visualizar todas as depend√™ncias de uma classe logo de in√≠cio, sem a
                necessidade de examinar todos os campos ou anota√ß√µes espalhadas pela classe. Esse aspecto torna o c√≥digo
                mais autodescritivo, o que facilita a compreens√£o tanto por outros desenvolvedores quanto por
                ferramentas de an√°lise est√°tica.</p>
            <p>A inje√ß√£o via construtor tamb√©m ajuda a evitar <strong>depend√™ncias ocultas ou parcialmente
                    injetadas</strong>. A inje√ß√£o em atributos ocorre ap√≥s a constru√ß√£o do objeto, o que pode gerar
                problemas em m√©todos anotados com <code>@PostConstruct</code> ou em inicializa√ß√µes que dependam dessas
                inje√ß√µes logo na cria√ß√£o do bean. J√° com o construtor, as depend√™ncias s√£o garantidas no momento da
                cria√ß√£o do objeto, tornando o ciclo de vida mais previs√≠vel e seguro. Por exemplo, imagine um cen√°rio em
                que uma classe ReportService utiliza uma depend√™ncia chamada EmailService, injetada com @Autowired, e
                dentro do m√©todo init(), anotado com @PostConstruct, tenta us√°-la imediatamente. Existe o risco de
                emailService ainda n√£o estar injetado nesse momento, resultando em um NullPointerException dif√≠cil de
                diagnosticar. Ao utilizar inje√ß√£o via construtor, no entanto, esse risco desaparece, pois o Spring s√≥
                consegue instanciar o objeto ReportService se todas as depend√™ncias passadas no construtor forem
                resolvidas previamente. Assim, ao chegar no @PostConstruct, temos a certeza de que o objeto est√°
                completamente pronto para uso, com todas as depend√™ncias j√° dispon√≠veis. O c√≥digo abaixo mostra esse
                cen√°rio:</p>
            <pre><code class="language-java">@Component
public class ReportService {

    @Autowired
    private EmailService emailService;

    private String status;

    @PostConstruct
    public void init() {
        // Tentamos usar o emailService logo ap√≥s a constru√ß√£o do bean
        this.status = emailService.sendReport(&quot;Relat√≥rio inicial&quot;);
    }
}
</code></pre>
            <p>Se o <code>EmailService</code> ainda n√£o tiver sido injetado no momento em que o m√©todo init() √©
                executado, isso pode gerar um <code>NullPointerException</code>. Esse tipo de erro √© sutil, porque
                depende do ciclo de vida do Spring, do modo como o bean √© criado, se h√° proxies envolvidos, e da ordem
                de inicializa√ß√£o dos beans. Embora o Spring costume cuidar disso corretamente na maioria dos casos, √© um
                risco real quando usamos <code>@Autowired</code> diretamente no atributo.</p>
            <p>Al√©m disso, essa pr√°tica de inje√ß√£o via construtor se integra muito bem com ferramentas como o
                <strong>Lombok</strong>. Ao declarar os atributos como <code>final</code>, √© poss√≠vel usar a anota√ß√£o
                <code>@RequiredArgsConstructor</code>, que automaticamente gera um construtor com todos os campos
                necess√°rios, eliminando a necessidade de escrever c√≥digo adicional, ao mesmo tempo em que preserva todos
                os benef√≠cios da inje√ß√£o via construtor.</p>
            <p>Naturalmente, h√° exce√ß√µes. Em classes muito simples ou com apenas uma depend√™ncia, a utiliza√ß√£o direta de
                <code>@Autowired</code> pode ser aceit√°vel. E se uma classe possui muitas depend√™ncias (acima de 4 ou
                5), isso pode ser um sinal de que ela est√° assumindo responsabilidades demais, sendo mais adequado
                refator√°-la antes de decidir pela forma de inje√ß√£o. </p>
            <p>Em resumo, a inje√ß√£o de depend√™ncia via construtor promove <strong>imutabilidade, testabilidade,
                    legibilidade e seguran√ßa</strong>, al√©m de favorecer a manuten√ß√£o e evolu√ß√£o do c√≥digo. Por essas
                raz√µes, ela √© atualmente a abordagem <strong>mais recomendada no ecossistema Spring</strong>,
                especialmente em classes anotadas com <code>@Service</code>, <code>@Controller</code>,
                <code>@Component</code> e <code>@RestController</code>.</p>
            <p>Vamos agora analisar os m√©todos!</p>
            <h3>üîé M√©todo 1: <code>getAllContacts(Pageable pageable)</code></h3>
            <pre><code class="language-java">/**
* Retorna uma lista paginada de todos os contatos.
* 
* @param pageable informa√ß√µes de pagina√ß√£o
* @return p√°gina de contatos
*/
@Operation(summary = &quot;Listar todos os contatos&quot;, description = &quot;Retorna uma lista paginada de todos os contatos cadastrados no sistema&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contatos encontrados com sucesso&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@GetMapping
public ResponseEntity&lt;Page&lt;ContactResponseDTO&gt;&gt; getAllContacts(Pageable pageable) {
    Page&lt;Contact&gt; contacts = contactRepository.findAll(pageable);
    Page&lt;ContactResponseDTO&gt; responseDTO = contacts
        .map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
    return ResponseEntity.ok(responseDTO);
}
</code></pre>
            <p>Acabamos de ver esse m√©todo na explica√ß√£o acima, mas vamos refor√ßar os conceitos.</p>
            <p>Este m√©todo √© respons√°vel por retornar todos os contatos cadastrados, com suporte √† pagina√ß√£o. A anota√ß√£o
                <code>@GetMapping</code> exp√µe o m√©todo via HTTP GET na URL <code>/api/contacts</code>.</p>
            <p>Como vimos na aula anterior, o par√¢metro <code>Pageable pageable</code> √© um objeto especial do Spring
                Data que encapsula informa√ß√µes sobre a requisi√ß√£o de pagina√ß√£o: n√∫mero da p√°gina (<code>page</code>),
                tamanho da p√°gina (<code>size</code>) e crit√©rio de ordena√ß√£o (<code>sort</code>). Esses par√¢metros
                podem ser passados diretamente pela URL. Por exemplo:</p>
            <pre><code>GET /api/contacts?page=0&amp;size=10&amp;sort=nome,asc
</code></pre>
            <p>Internamente, o m√©todo chama <code>contactRepository.findAll(pageable)</code> para buscar os dados j√°
                paginados no banco de dados. O retorno √© um <code>Page&lt;Contact&gt;</code>, uma interface que
                representa uma &quot;p√°gina&quot; de objetos com metadados como total de elementos, n√∫mero da p√°gina,
                n√∫mero total de p√°ginas etc.</p>
            <p>Em seguida, cada objeto <code>Contact</code> √© mapeado para <code>ContactResponseDTO</code> usando o
                <code>ModelMapper</code>, uma biblioteca que converte objetos com base em seus atributos de mesmo nome
                (configurada e adicionada ao projeto na aula anterior). O m√©todo <code>map()</code> da interface
                <code>Page</code> √© usado aqui:</p>
            <pre><code class="language-java">Page&lt;ContactResponseDTO&gt; responseDTO = contacts
        .map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
</code></pre>
            <p>Aqui, <code>contacts</code> √© um objeto do tipo <code>Page&lt;Contact&gt;</code>, ou seja, uma lista
                paginada de contatos. O m√©todo <code>map()</code> da interface <code>Page</code> aplica uma
                transforma√ß√£o a cada elemento da lista interna, retornando um novo <code>Page</code> com os elementos
                convertidos ‚Äî nesse caso, de <code>Contact</code> para <code>ContactResponseDTO</code>.</p>
            <p>A transforma√ß√£o √© feita atrav√©s de uma <code>Function&lt;T, R&gt;</code>, fornecida por meio de uma
                express√£o lambda. Uma <code>Function&lt;T, R&gt;</code> √© uma interface funcional da API de fun√ß√µes do
                Java (<code>java.util.function</code>) que representa uma fun√ß√£o que recebe um valor do tipo
                <code>T</code> e retorna um valor do tipo <code>R</code>. Em outras palavras, √© uma fun√ß√£o que
                transforma um valor de um tipo em outro. Vamos exemplificar com um c√≥digo simples que transforma um
                inteiro em uma String:</p>
            <pre><code class="language-java">Function&lt;Integer, String&gt; intToString = num -&gt; &quot;N√∫mero: &quot; + num;

String resultado = intToString.apply(10);
// resultado: &quot;N√∫mero: 10&quot;
</code></pre>
            <p>Esse trecho de c√≥digo acima utiliza a interface funcional <code>Function&lt;T, R&gt;</code> da API do
                Java para definir uma fun√ß√£o que recebe um n√∫mero inteiro (<code>Integer</code>) como entrada e retorna
                uma <code>String</code> como sa√≠da.</p>
            <p>Na linha:</p>
            <pre><code class="language-java">Function&lt;Integer, String&gt; intToString = num -&gt; &quot;N√∫mero: &quot; + num;
</code></pre>
            <p>estamos criando uma vari√°vel chamada <code>intToString</code> do tipo
                <code>Function&lt;Integer, String&gt;</code>. Isso significa que essa fun√ß√£o aceitar√° um valor do tipo
                <code>Integer</code> (n√∫mero inteiro) e retornar√° um valor do tipo <code>String</code>. A implementa√ß√£o
                √© feita com uma express√£o lambda: <code>num -&gt; &quot;N√∫mero: &quot; + num</code>, o que quer dizer
                que, ao receber um n√∫mero <code>num</code>, a fun√ß√£o concatenar√° a string
                <code>&quot;N√∫mero: &quot;</code> com esse n√∫mero, produzindo uma nova string como resultado.</p>
            <p>Em seguida, temos a linha:</p>
            <pre><code class="language-java">String resultado = intToString.apply(10);
</code></pre>
            <p>Aqui, estamos chamando o m√©todo <code>apply</code> da fun√ß√£o, passando o valor <code>10</code> como
                argumento. Isso faz com que a fun√ß√£o seja executada e retorne a string
                <code>&quot;N√∫mero: 10&quot;</code>, que √© atribu√≠da √† vari√°vel <code>resultado</code>.</p>
            <p>Portanto, ao final da execu√ß√£o desse trecho, a vari√°vel <code>resultado</code> conter√° o valor
                <code>&quot;N√∫mero: 10&quot;</code>. Esse exemplo ilustra de forma simples como a interface
                <code>Function</code> pode ser usada para representar transforma√ß√µes de dados no estilo funcional.</p>
            <p>Da mesma forma, o modelMapper.map(...) √© invocado para cada Contact e transforma o objeto em seu
                correspondente ContactResponseDTO. A express√£o
                <code>contact -&gt; modelMapper.map(contact, ContactResponseDTO.class)</code> √© uma
                <code>Function&lt;Contact, ContactResponseDTO&gt;</code>!</p>
            <p>üí°Caso a explica√ß√£o n√£o tenha ficado suficientemente clara, consulte a <a
                    href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Documenta√ß√£o da
                    interface Function (Java 8)</a> e tamb√©m o artigo da Baeldung, <a
                    href="https://www.baeldung.com/java-8-functional-interfaces">Baeldung: Java 8 Functional
                    Interfaces</a>.</p>
            <p>Por fim, o m√©todo retorna o resultado com <code>ResponseEntity.ok(responseDTO)</code>, encapsulando o
                conte√∫do e o c√≥digo de status HTTP 200 (OK).</p>
            <p>Feitas essas considera√ß√µes, passemos ao pr√≥ximo m√©todo!</p>
            <h3>üîé M√©todo 2: <code>getContactById(Long id)</code></h3>
            <pre><code class="language-java">/**
* Busca um contato pelo ID.
* 
* @param id identificador do contato
* @return contato encontrado
* @throws ResourceNotFoundException se o contato n√£o for encontrado
*/
@Operation(summary = &quot;Buscar contato por ID&quot;, description = &quot;Retorna um contato espec√≠fico com base no ID fornecido&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato encontrado com sucesso&quot;),
    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@GetMapping(&quot;/{id}&quot;)
public ResponseEntity&lt;ContactResponseDTO&gt; getContactById(@PathVariable Long id) {
    Contact contact = contactRepository.findById(id)
        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

    ContactResponseDTO responseDTO = modelMapper.map(contact, ContactResponseDTO.class);
    return ResponseEntity.ok(responseDTO);
}
</code></pre>
            <p>Este m√©todo busca um contato espec√≠fico a partir de seu <code>id</code>. A anota√ß√£o
                <code>@PathVariable</code> indica que o valor da vari√°vel <code>id</code> ser√° extra√≠do diretamente da
                URL (por exemplo: <code>/api/contacts/5</code>), como vimos nas aulas anteriores.</p>
            <p>O m√©todo tenta encontrar o contato via <code>contactRepository.findById(id)</code>. Caso o contato n√£o
                exista, √© lan√ßada uma exce√ß√£o personalizada <code>ResourceNotFoundException</code>, que ser√° tratada
                pelo <code>GlobalHandlerException</code> (visto na aula 04), um <code>@ControllerAdvice</code> global da
                aplica√ß√£o.</p>
            <p>O c√≥digo utiliza dois recursos importantes em aplica√ß√µes modernas com Spring Boot: o m√©todo
                <code>.orElseThrow()</code> da classe <code>Optional</code>, e as anota√ß√µes do Swagger (mais
                precisamente, da especifica√ß√£o OpenAPI 3) para documenta√ß√£o autom√°tica da API. Vamos entender cada parte
                com mais profundidade.</p>
            <p>O m√©todo <code>.orElseThrow()</code> √© uma forma moderna e concisa de tratar situa√ß√µes em que um valor
                pode ou n√£o estar presente, representado por um objeto <code>Optional</code>. Vimos o uso de
                <code>Optional</code> nas aulas 03, 04 e 05. Mesmo assim, vamos refor√ßar o que √© e como funciona. No
                contexto do c√≥digo:</p>
            <pre><code class="language-java">Contact contact = contactRepository.findById(id)
    .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
</code></pre>
            <p>A chamada <code>contactRepository.findById(id)</code> retorna um <code>Optional&lt;Contact&gt;</code> ‚Äî
                ou seja, um recipiente que <strong>pode ou n√£o conter</strong> um objeto <code>Contact</code>. Isso √©
                uma forma segura de evitar exce√ß√µes como <code>NullPointerException</code>, for√ßando o desenvolvedor a
                lidar com a possibilidade de aus√™ncia do valor.</p>
            <p>O m√©todo <code>.orElseThrow()</code> verifica se h√° um valor presente. Caso <strong>haja</strong>, o
                valor √© retornado. Caso <strong>n√£o haja</strong>, a fun√ß√£o passada como argumento √© executada, lan√ßando
                uma exce√ß√£o customizada ‚Äî no caso, uma <code>ResourceNotFoundException</code> com uma mensagem
                personalizada. Isso permite que o controle de fluxo seja feito de maneira limpa, sem necessidade de
                <code>if (contact == null)</code> ou blocos <code>try/catch</code>.</p>
            <p>Esse padr√£o torna o c√≥digo mais expressivo, seguro e aderente ao paradigma funcional introduzido com o
                <code>Optional</code> a partir do Java 8.</p>
            <p>Al√©m disso, o trecho de c√≥digo tamb√©m utiliza anota√ß√µes da biblioteca <code>springdoc-openapi</code>
                (implementa√ß√£o da especifica√ß√£o OpenAPI para projetos Spring Boot) para gerar automaticamente
                documenta√ß√£o interativa da API ‚Äî geralmente acess√≠vel via <code>/swagger-ui.html</code> ou
                <code>/swagger-ui/index.html</code>. </p>
            <pre><code class="language-java">@Operation(summary = &quot;Buscar contato por ID&quot;, description = &quot;Retorna um contato espec√≠fico com base no ID fornecido&quot;)
</code></pre>
            <p>Essa anota√ß√£o descreve o prop√≥sito do endpoint. O campo <code>summary</code> √© uma descri√ß√£o curta e
                objetiva, enquanto o <code>description</code> pode conter mais detalhes. Essa informa√ß√£o ser√° exibida na
                interface gr√°fica do Swagger e tamb√©m usada na gera√ß√£o de documenta√ß√£o no formato JSON/YAML da OpenAPI.
            </p>
            <pre><code class="language-java">@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato encontrado com sucesso&quot;),
    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
</code></pre>
            <p>J√£ essa estrutura acima define <strong>quais respostas o endpoint pode retornar</strong>, informando:</p>
            <ul>
                <li>O <strong>c√≥digo HTTP</strong> (<code>responseCode</code>) que pode ser devolvido,</li>
                <li>A <strong>descri√ß√£o textual</strong> do que esse c√≥digo representa no contexto da opera√ß√£o,</li>
                <li>E opcionalmente, o <strong>conte√∫do da resposta</strong> via <code>@Content</code> (nesse exemplo,
                    deixado vazio).</li>
            </ul>
            <p>Essas anota√ß√µes ajudam outras pessoas desenvolvedoras ‚Äî e at√© o pr√≥prio time ‚Äî a compreender rapidamente
                o comportamento esperado da API, suas poss√≠veis respostas e os erros que podem ocorrer, tudo de forma
                automatizada e centralizada.</p>
            <p>Em resumo, o m√©todo <code>.orElseThrow()</code> traz eleg√¢ncia e seguran√ßa ao tratamento de dados
                opcionais, eliminando verifica√ß√µes manuais de nulo e oferecendo uma forma fluente de lan√ßar exce√ß√µes
                customizadas. J√° as anota√ß√µes <code>@Operation</code> e <code>@ApiResponses</code> s√£o fundamentais para
                gerar documenta√ß√£o autom√°tica, interativa e padronizada da API, que tornam o sistema mais compreens√≠vel,
                f√°cil de usar e alinhado √†s boas pr√°ticas de desenvolvimento de software moderno. üòä</p>
            <p>Por fim, se o contato for encontrado, ele √© convertido para <code>ContactResponseDTO</code> usando o
                <code>ModelMapper</code> e retornado dentro de um <code>ResponseEntity</code>.</p>
            <h3>üîé M√©todo 3: <code>createContact(ContactRequestDTO dto)</code></h3>
            <pre><code class="language-java">/**
* Cria um novo contato.
* 
* @param dto dados do contato a ser criado
* @return contato criado
*/
@Operation(summary = &quot;Criar novo contato&quot;, description = &quot;Cria um novo contato com os dados fornecidos&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Contato criado com sucesso&quot;),
    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Dados inv√°lidos&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@PostMapping
public ResponseEntity&lt;ContactResponseDTO&gt; createContact(@Valid @RequestBody ContactRequestDTO dto) {
    Contact contact = modelMapper.map(dto, Contact.class);
    contact.getAddresses().forEach(address -&gt; address.setContact(contact));
    Contact saved = contactRepository.save(contact);
    ContactResponseDTO responseDTO = modelMapper.map(saved, ContactResponseDTO.class);
    return ResponseEntity.status(HttpStatus.CREATED).body(responseDTO);
}
</code></pre>
            <p>Este m√©todo √© respons√°vel por criar um novo contato. A anota√ß√£o <code>@PostMapping</code> define que ele
                ser√° acessado via HTTP POST. A anota√ß√£o <code>@RequestBody</code> indica que o corpo da requisi√ß√£o ser√°
                convertido para um objeto <code>ContactRequestDTO</code>, que representa os dados recebidos. Relembrando
                o que vimos nas aulas anteriores, a anota√ß√£o <code>@RequestBody</code> no Spring Boot tem um papel
                importante em m√©todos que recebem dados enviados pelo cliente no corpo de uma requisi√ß√£o HTTP ‚Äî
                geralmente em requisi√ß√µes do tipo <code>POST</code>, <code>PUT</code> ou <code>PATCH</code>. </p>
            <p>Quando essa anota√ß√£o √© aplicada a um par√¢metro de um m√©todo no controller, como no caso:</p>
            <pre><code class="language-java">public ResponseEntity&lt;ContactResponseDTO&gt; createContact(@Valid @RequestBody ContactRequestDTO dto)
</code></pre>
            <p>ela <strong>instrui o Spring</strong> a <strong>deserializar automaticamente o corpo da requisi√ß√£o
                    (normalmente em JSON)</strong> para uma inst√¢ncia da classe especificada, neste caso,
                <code>ContactRequestDTO</code>. Ou seja, o Spring ir√°:</p>
            <ol>
                <li>Ler o corpo da requisi√ß√£o HTTP (por exemplo, um JSON enviado via POST);</li>
                <li>Usar uma biblioteca de mapeamento de objetos (por padr√£o, o Jackson) para converter os dados para o
                    tipo <code>ContactRequestDTO</code>;</li>
                <li>Entregar esse objeto j√° populado ao m√©todo do controller, pronto para ser utilizado na l√≥gica de
                    neg√≥cios.</li>
            </ol>
            <p>Por exemplo, se o cliente enviar a seguinte requisi√ß√£o:</p>
            <pre><code class="language-http">POST /api/contacts
Content-Type: application/json

{
  &quot;nome&quot;: &quot;Maria Oliveira&quot;,
  &quot;email&quot;: &quot;maria@email.com&quot;,
  &quot;telefone&quot;: &quot;11999999999&quot;,
  &quot;addresses&quot;: [
    {
      &quot;rua&quot;: &quot;Rua das Flores&quot;,
      &quot;cidade&quot;: &quot;S√£o Paulo&quot;,
      &quot;estado&quot;: &quot;SP&quot;,
      &quot;cep&quot;: &quot;01234-567&quot;
    }
  ]
}
</code></pre>
            <p>O Spring automaticamente transforma esse corpo JSON em um objeto <code>ContactRequestDTO</code> com os
                respectivos campos preenchidos ‚Äî sem que o desenvolvedor precise escrever manualmente qualquer c√≥digo de
                parsing ou convers√£o.</p>
            <p>Al√©m disso, como o DTO √© anotado com <code>@Valid</code>, o Spring tamb√©m realiza <strong>valida√ß√£o
                    autom√°tica dos campos</strong> com base nas anota√ß√µes de Bean Validation (como
                <code>@NotBlank</code>, <code>@Email</code>, etc.). Se houver qualquer erro de valida√ß√£o, o Spring
                lan√ßar√° uma exce√ß√£o do tipo <code>MethodArgumentNotValidException</code>, que pode ser tratada
                globalmente para retornar uma resposta padronizada de erro.</p>
            <p>Portanto, o uso do <code>@RequestBody</code> promove maior desacoplamento entre os dados da requisi√ß√£o e
                a l√≥gica da aplica√ß√£o, al√©m de permitir a integra√ß√£o limpa com valida√ß√£o e documenta√ß√£o autom√°tica da
                API.</p>
            <p>O objeto DTO √© convertido diretamente para a entidade <code>Contact</code> com o
                <code>ModelMapper</code>. Contudo, como a entidade <code>Contact</code> tem uma rela√ß√£o bidirecional com
                <code>Address</code> (endere√ßos), √© necess√°rio que cada endere√ßo tenha seu campo <code>contact</code>
                corretamente associado. Isso √© feito manualmente com:</p>
            <pre><code class="language-java">contact.getAddresses().forEach(address -&gt; address.setContact(contact));
</code></pre>
            <p>Aqui estamos usando, novamente, a interface funcional do Java para facilitar nossa sintaxe. A linha acima
                √© equivalente a:</p>
            <pre><code class="language-java">for (Address address : contact.getAddresses()) {
    address.setContact(contact);
}
</code></pre>
            <p>De qualquer forma, seja usando a forma funcional (com <code>Lambda</code>) ou imperativa (com
                <code>foreach</code>), sem esse trecho o campo <code>contact</code> dentro de cada <code>Address</code>
                ficaria <code>null</code>. Como resultado:</p>
            <ul>
                <li>O JPA/Hibernate n√£o conseguiria gerar corretamente a chave estrangeira (<code>contact_id</code>, por
                    exemplo) na tabela de endere√ßos;</li>
                <li>Poderiam surgir erros de integridade referencial no banco de dados;</li>
            </ul>
            <p>Depois de configurar as associa√ß√µes, o contato √© salvo via <code>contactRepository.save(contact)</code>.
                O objeto salvo (que agora tem <code>id</code> e os endere√ßos com <code>contact_id</code>) √© convertido
                para <code>ContactResponseDTO</code> e retornado com c√≥digo 201 (CREATED) usando:</p>
            <pre><code class="language-java">return ResponseEntity.status(HttpStatus.CREATED).body(responseDTO);
</code></pre>
            <p>E assim, mais um m√©todo de nosso Controller est√° refatorado. Passemos ao pr√≥ximo!</p>
            <h3>üîé M√©todo 4: <code>updateContact(Long id, ContactRequestDTO dto)</code></h3>
            <pre><code class="language-java">/**
* Atualiza um contato existente.
* 
* @param id  identificador do contato
* @param dto novos dados do contato
* @return contato atualizado
* @throws ResourceNotFoundException se o contato n√£o for encontrado
*/
@Operation(summary = &quot;Atualizar contato&quot;, description = &quot;Atualiza todos os dados de um contato existente&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato atualizado com sucesso&quot;),
    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Dados inv√°lidos&quot;),
    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@PutMapping(&quot;/{id}&quot;)
public ResponseEntity&lt;ContactResponseDTO&gt; updateContact(@PathVariable Long id, @Valid @RequestBody ContactRequestDTO dto) {
    Contact existingContact = contactRepository.findById(id)
        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

    modelMapper.map(dto, existingContact);
    existingContact.getAddresses().forEach(address -&gt; address.setContact(existingContact));
    Contact updated = contactRepository.save(existingContact);
    ContactResponseDTO responseDTO = modelMapper.map(updated, ContactResponseDTO.class);
    return ResponseEntity.ok(responseDTO);
}
</code></pre>
            <p>O m√©todo <code>updateContact</code> √© respons√°vel por <strong>atualizar completamente</strong> os dados
                de um contato j√° existente. Aqui utilizamos a anota√ß√£o <code>@PutMapping</code>, que, conforme o padr√£o
                REST que vimos na Aula 03, indica que a atualiza√ß√£o deve substituir <strong>integralmente</strong> o
                recurso identificado.</p>
            <p>O processo come√ßa com a tentativa de buscar o contato no banco de dados pelo <code>id</code> informado na
                URL. Caso o contato n√£o seja encontrado, a exce√ß√£o personalizada do tipo
                <code>ResourceNotFoundException</code> √© lan√ßada, retornando uma resposta HTTP 404 (Not Found).</p>
            <p>Se o contato for encontrado, o objeto <code>ContactRequestDTO</code> enviado no corpo da requisi√ß√£o √©
                mapeado para o objeto <code>Contact</code> existente usando o <code>ModelMapper</code>. O mesmo processo
                que usamos anteriormente üòä</p>
            <p>Nesse m√©todo (<code>updateContact</code>), o mapeamento autom√°tico do <code>ModelMapper</code> √© usado
                para substituir os dados antigos pelos novos ‚Äî com exce√ß√£o de associa√ß√µes que exigem tratamento
                especial, como a rela√ß√£o entre <code>Contact</code> e seus <code>Address</code>.</p>
            <p>Logo ap√≥s, associamos os endere√ßos ao contato por meio da seguinte opera√ß√£o:</p>
            <pre><code class="language-java">existingContact.getAddresses().forEach(address -&gt; address.setContact(existingContact));
</code></pre>
            <p>Esse trecho percorre a lista de endere√ßos (<code>addresses</code>) associados ao contato e, para
                <strong>cada um deles</strong>, define explicitamente o <code>Contact</code> pai. Esse <em>bind
                    reverso</em> √© necess√°rio porque, ao mapear o DTO para a entidade, o <code>ModelMapper</code>
                <strong>n√£o estabelece automaticamente</strong> essa associa√ß√£o de volta. Em outras palavras, os
                endere√ßos sabem seus pr√≥prios dados (rua, cidade, etc.), mas n√£o sabem a quem pertencem ‚Äî e isso precisa
                ser explicitado manualmente.</p>
            <p>Isso acontece porque os objetos <code>Address</code> recebidos via DTO n√£o carregam, por padr√£o, a
                refer√™ncia para o contato pai (<code>Contact</code>). Essa refer√™ncia √© essencial para manter a
                integridade da rela√ß√£o bidirecional entre as entidades e permitir que o JPA gere corretamente a chave
                estrangeira na tabela de endere√ßos.</p>
            <p><strong>N√≥s poder√≠amos ter configurado isso criando <code>TypeMaps</code> personalizados</strong>, que
                permitem instruir o <code>ModelMapper</code> a <strong>ignorar ou tratar de forma espec√≠fica certos
                    campos</strong>, como listas aninhadas ou rela√ß√µes bidirecionais. Por exemplo, para <strong>evitar
                    que o <code>ModelMapper</code> substitua diretamente a lista de endere√ßos sem realizar o v√≠nculo
                    reverso com o <code>Contact</code></strong>, podemos configurar um <code>TypeMap</code> que
                <strong>ignore o mapeamento autom√°tico do campo <code>addresses</code></strong> e depois fazer o
                controle manual. Dessa forma, <strong>ganhar√≠amos um pouco mais de clareza e previsibilidade no
                    mapeamento</strong>, especialmente em estruturas mais complexas com relacionamentos bidirecionais.
                Isso serve o prop√≥sito de evitar poss√≠veis erros de persist√™ncia, como viola√ß√£o de integridade
                referencial, e facilita a manuten√ß√£o do c√≥digo, pois o mapeamento torna-se expl√≠cito apenas onde
                realmente √© necess√°rio.</p>
            <p>Novamente: n√£o optamos por essa configura√ß√£o justamente porque estamos seguindo uma abordagem
                <strong>evolutiva e pedag√≥gica</strong> no desenvolvimento do projeto ‚Äî o objetivo √© <strong>compreender
                    passo a passo os motivos por tr√°s de cada decis√£o</strong>, construindo conhecimento s√≥lido antes de
                introduzir abstra√ß√µes mais avan√ßadas.</p>
            <p>Ap√≥s esse ajuste, o contato √© salvo novamente no reposit√≥rio (persistido no banco de dados), e a entidade
                atualizada √© convertida para <code>ContactResponseDTO</code>, que ser√° retornado ao cliente com uma
                resposta <code>200 OK</code>.</p>
            <h3>üîé M√©todo 5: <code>updateContactPartial(Long id, ContactPatchDTO dto)</code></h3>
            <pre><code class="language-java">/**
* Atualiza parcialmente um contato existente.
* 
* @param id  identificador do contato
* @param dto dados a serem atualizados
* @return contato atualizado
* @throws ResourceNotFoundException se o contato n√£o for encontrado
*/
@Operation(summary = &quot;Atualizar contato parcialmente&quot;, description = &quot;Atualiza apenas os campos especificados de um contato existente&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Contato atualizado com sucesso&quot;),
    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@PatchMapping(&quot;/{id}&quot;)
public ResponseEntity&lt;ContactResponseDTO&gt; updateContactPartial(@PathVariable Long id, @RequestBody ContactPatchDTO dto) {
    Contact existingContact = contactRepository.findById(id)
        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
    dto.getNome().ifPresent(existingContact::setNome);
    dto.getEmail().ifPresent(existingContact::setEmail);
    dto.getTelefone().ifPresent(existingContact::setTelefone);
    Contact saved = contactRepository.save(existingContact);
    ContactResponseDTO responseDTO = modelMapper.map(saved, ContactResponseDTO.class);
    return ResponseEntity.ok(responseDTO);
}
</code></pre>
            <p>O m√©todo <code>updateContactPartial</code> tem como objetivo realizar a <strong>atualiza√ß√£o
                    parcial</strong> de um contato existente no sistema, utilizando o padr√£o HTTP
                <strong>PATCH</strong>. Esse padr√£o indica que apenas parte dos dados de um recurso ser√° modificada, ao
                contr√°rio do PUT, que exige a substitui√ß√£o completa. Lembrem-se que abordamos esse conceito nas aulas
                anteriores. ü§ì</p>
            <p>Ao receber uma requisi√ß√£o com o identificador (<code>id</code>) do contato e um corpo contendo apenas os
                campos que devem ser atualizados, o m√©todo come√ßa realizando uma busca pelo contato correspondente no
                reposit√≥rio. Caso n√£o exista, uma exce√ß√£o do tipo <code>ResourceNotFoundException</code> √© lan√ßada,
                resultando em uma resposta HTTP 404 (Not Found).</p>
            <p>O DTO utilizado neste m√©todo √© o <code>ContactPatchDTO</code>, cuja principal caracter√≠stica √© que seus
                atributos s√£o declarados como <code>Optional&lt;String&gt;</code>. Essa escolha √© intencional e permite
                diferenciar com clareza se um campo foi de fato enviado na requisi√ß√£o ou n√£o. Por exemplo,
                <code>Optional.empty()</code> indica que o campo n√£o foi enviado, enquanto
                <code>Optional.of(&quot;valor&quot;)</code> indica que o campo foi fornecido e deve ser processado.</p>
            <p>A l√≥gica do m√©todo utiliza o m√©todo <code>ifPresent</code> de cada <code>Optional</code> para atualizar
                apenas os campos que est√£o presentes. Veja o trecho:</p>
            <pre><code class="language-java">dto.getNome().ifPresent(existingContact::setNome);
dto.getEmail().ifPresent(existingContact::setEmail);
dto.getTelefone().ifPresent(existingContact::setTelefone);
</code></pre>
            <p>Cada chamada acima verifica se o campo est√° presente no DTO. Se estiver, o valor √© passado ao m√©todo
                <code>set</code> correspondente do objeto <code>Contact</code> existente. Caso n√£o esteja, o campo
                permanece inalterado.</p>
            <p><strong>ü§î E essa sintaxe com uso de <code>::</code>?</strong></p>
            <p>A express√£o <code>existingContact::setNome</code> (bem como as demais) representa uma <strong>refer√™ncia
                    de m√©todo</strong> (ou <em>method reference</em>), uma funcionalidade introduzida no Java 8 que
                permite passar m√©todos como argumentos de forma mais concisa e leg√≠vel. No contexto do c√≥digo
                <code>dto.getNome().ifPresent(existingContact::setNome);</code>, essa refer√™ncia est√° sendo usada para
                aplicar uma fun√ß√£o ao valor presente em um <code>Optional</code>.</p>
            <p>Mais especificamente, <code>existingContact::setNome</code> √© uma forma simplificada de escrever uma
                <em>lambda expression</em> como <code>nome -&gt; existingContact.setNome(nome)</code>. Ambas executam a
                mesma opera√ß√£o, mas a vers√£o com <code>::</code> torna o c√≥digo mais enxuto e elegante. O m√©todo
                <code>ifPresent</code> da classe <code>Optional</code> aceita um argumento do tipo
                <code>Consumer&lt;T&gt;</code>, ou seja, uma fun√ß√£o que recebe um par√¢metro e retorna <code>void</code>.
                Como <code>setNome(String nome)</code> satisfaz essa exig√™ncia ‚Äî recebe uma <code>String</code> e n√£o
                retorna nada ‚Äî ele pode ser referenciado diretamente com a sintaxe
                <code>existingContact::setNome</code>.</p>
            <p>Mesmo que o m√©todo <code>setNome</code> n√£o esteja declarado explicitamente na classe
                <code>Contact</code>, o uso do Lombok (atrav√©s de anota√ß√µes como <code>@Data</code>,
                <code>@Setter</code>, ou <code>@Builder</code>) garante que esse m√©todo seja gerado em tempo de
                compila√ß√£o. Isso significa que o compilador reconhece e permite o uso da refer√™ncia ao m√©todo, mesmo que
                ele n√£o esteja vis√≠vel no c√≥digo-fonte.</p>
            <p>Ou seja, h√° duas formas poss√≠veis de aplicar o valor de <code>dto.getNome()</code> ao objeto
                <code>existingContact</code>:</p>
            <p><strong>Com lambda:</strong></p>
            <pre><code class="language-java">dto.getNome().ifPresent(nome -&gt; existingContact.setNome(nome));
</code></pre>
            <p><strong>Com method reference (forma preferida):</strong></p>
            <pre><code class="language-java">dto.getNome().ifPresent(existingContact::setNome);
</code></pre>
            <p>A segunda forma √© preferida quando poss√≠vel, pois reduz o boilerplate, melhora a clareza e facilita a
                leitura do c√≥digo. Esse tipo de recurso √© especialmente √∫til em opera√ß√µes com <code>Optional</code>,
                <code>Stream</code>, ou qualquer outra API funcional introduzida no Java 8.</p>
            <p>Capisci? ü§å</p>
            <p>Voltando ao fluxo de execu√ß√£o do nosso m√©todo, ap√≥s aplicar as altera√ß√µes o objeto atualizado √© salvo no
                banco de dados com <code>contactRepository.save(existingContact)</code>. Em seguida, o objeto persistido
                √© convertido em um DTO de resposta (<code>ContactResponseDTO</code>) por meio do
                <code>ModelMapper</code>, e retornado ao cliente com o status HTTP 200 (OK).</p>
            <h3>üîé M√©todo 6: <code>deleteContact(Long id)</code></h3>
            <pre><code class="language-java">/**
 * * Exclui um contato.
* 
* @param id identificador do contato
* @return resposta sem conte√∫do
* @throws ResourceNotFoundException se o contato n√£o for encontrado
*/
@Operation(summary = &quot;Excluir contato&quot;, description = &quot;Remove permanentemente um contato do sistema&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Contato exclu√≠do com sucesso&quot;),
    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Contato n√£o encontrado&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@DeleteMapping(&quot;/{id}&quot;)
public ResponseEntity&lt;Void&gt; deleteContact(@PathVariable Long id) {
    if (!contactRepository.existsById(id)) {
        throw new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id);
    }
    contactRepository.deleteById(id);
    return ResponseEntity.noContent().build();
}
</code></pre>
            <p>Outro m√©todo que j√° vimos na se√ß√£o anterior, mas s√≥ para refor√ßar: este m√©todo exclui um contato com base
                no <code>id</code>. A anota√ß√£o <code>@DeleteMapping</code> indica uma opera√ß√£o de dele√ß√£o. Antes da
                exclus√£o, √© verificado se o contato realmente existe com <code>existsById</code>. Se n√£o existir, uma
                exce√ß√£o √© lan√ßada. </p>
            <p>Se a exclus√£o ocorrer com sucesso, o retorno √© <code>ResponseEntity.noContent().build()</code> com o
                c√≥digo de status HTTP 204, que indica sucesso sem conte√∫do: <code>.noContent()</code> √© um m√©todo
                est√°tico da classe ResponseEntity que retorna um <code>ResponseEntity.BodyBuilder</code> com o c√≥digo de
                status HTTP 204 j√° configurado e <code>.build()</code> √© o m√©todo que finaliza a constru√ß√£o da resposta
                sem corpo (ou seja, com null no body).</p>
            <h3>üîé M√©todo 7: <code>searchContactsByName(String name, Pageable pageable)</code></h3>
            <pre><code class="language-java">/**
* * Busca contatos pelo nome.
*
* @param name     nome ou parte do nome a ser pesquisado
* @param pageable informa√ß√µes de pagina√ß√£o
* @return lista paginada de contatos que correspondem ao crit√©rio de busca
*/
@Operation(summary = &quot;Buscar contatos por nome&quot;, description = &quot;Retorna uma lista paginada de contatos cujo nome cont√©m o termo pesquisado&quot;)
@ApiResponses(value = {
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Busca realizada com sucesso&quot;),
    @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;, content = @Content)
})
@GetMapping(&quot;/search&quot;)
public ResponseEntity&lt;Page&lt;ContactResponseDTO&gt;&gt; searchContactsByName(@RequestParam String name, Pageable pageable) {
    Page&lt;Contact&gt; contacts = contactRepository.findByNomeContainingIgnoreCase(name, pageable);
    Page&lt;ContactResponseDTO&gt; responseDTO = contacts
        .map(contact -&gt; modelMapper.map(contact, ContactResponseDTO.class));
    return ResponseEntity.ok(responseDTO);
}
</code></pre>
            <p>O m√©todo <code>searchContactsByName</code> √© respons√°vel por realizar uma busca paginada de contatos cujo
                nome contenha determinada substring informada como par√¢metro da requisi√ß√£o. O endpoint est√° mapeado para
                o caminho <code>/api/contacts/search</code> e responde a requisi√ß√µes HTTP GET.</p>
            <p>Novamente, todos os conceitos abordados abaixo j√° foram vistos, mas vamos refor√ß√°-los mesmo assim. üòå</p>
            <p>A busca funciona a partir do uso da anota√ß√£o <code>@RequestParam String name</code>, que indica que o
                par√¢metro <code>name</code> ser√° recebido por meio da <strong>query string</strong> da requisi√ß√£o. Por
                exemplo, uma chamada √† URL <code>/api/contacts/search?name=ana</code> resultar√° em uma busca por todos
                os contatos cujo nome contenha o texto &quot;ana&quot;, independentemente de letras mai√∫sculas ou
                min√∫sculas, gra√ßas ao uso do m√©todo <code>findByNomeContainingIgnoreCase</code> no reposit√≥rio (visto na
                aula anterior!).</p>
            <p>O segundo par√¢metro do m√©todo √© um objeto <code>Pageable</code>, que √© injetado automaticamente pelo
                Spring com base nos par√¢metros da requisi√ß√£o. Mais uma vez: a interface <code>Pageable</code> encapsula
                informa√ß√µes sobre a <strong>p√°gina atual</strong>, o <strong>tamanho da p√°gina</strong> e o
                <strong>crit√©rio de ordena√ß√£o</strong>, todos fornecidos via query string (ex:
                <code>?page=0&amp;size=10&amp;sort=nome,asc</code>). O Spring cuida de interpretar esses valores e
                construir um objeto <code>Pageable</code> correspondente.</p>
            <p>Com o <code>Pageable</code> em m√£os, o m√©todo consulta o reposit√≥rio usando
                <code>findByNomeContainingIgnoreCase</code>, que retorna um objeto <code>Page&lt;Contact&gt;</code>.
                Essa interface representa n√£o apenas os dados, mas tamb√©m metadados da consulta, como o n√∫mero total de
                p√°ginas, o n√∫mero da p√°gina atual, e o n√∫mero total de elementos. Isso √© extremamente √∫til em APIs REST
                que precisam fornecer pagina√ß√£o para o cliente de forma eficiente e padronizada.</p>
            <p>Em seguida, cada objeto <code>Contact</code> retornado pela consulta √© convertido em um
                <code>ContactResponseDTO</code>. No caso, usamos uma <strong>express√£o lambda</strong> com o
                <code>ModelMapper</code> para realizar essa convers√£o:
                <code>contact -&gt; modelMapper.map(contact, ContactResponseDTO.class)</code>.</p>
            <p>Por fim, o resultado ‚Äî agora representado como <code>Page&lt;ContactResponseDTO&gt;</code> ‚Äî √©
                encapsulado em um <code>ResponseEntity</code> com c√≥digo de status 200 (OK), utilizando
                <code>ResponseEntity.ok(...)</code>. O corpo da resposta inclui os dados paginados dos contatos, al√©m de
                informa√ß√µes √∫teis para o frontend, como a quantidade total de elementos, total de p√°ginas, tamanho da
                p√°gina, e indicadores se √© a primeira ou √∫ltima p√°gina.</p>
            <p>Essa abordagem oferece uma implementa√ß√£o aderente aos princ√≠pios REST. Al√©m disso, √© flex√≠vel o
                suficiente para permitir futuras evolu√ß√µes, como o uso de HATEOAS (com <code>PagedModel</code>) ou a
                personaliza√ß√£o de ordena√ß√µes e filtros.</p>
            <hr>
            <h3>üß† Considera√ß√µes Finais sobre a classe <code>ContactController</code></h3>
            <p>A classe <code>ContactController</code>, agora refatorada, apresenta uma estrutura alinhada com as boas
                pr√°ticas do desenvolvimento de APIs REST com Spring Boot. O uso de <code>Pageable</code> como par√¢metro
                nos m√©todos permite o controle eficiente sobre a pagina√ß√£o e ordena√ß√£o dos dados, tornando a API mais
                escal√°vel e flex√≠vel diante de grandes volumes de registros. O retorno como <code>Page</code> carrega,
                al√©m dos dados em si, informa√ß√µes √∫teis como n√∫mero total de elementos, total de p√°ginas, n√∫mero da
                p√°gina atual, e indicadores de primeira ou √∫ltima p√°gina, facilitando bastante a implementa√ß√£o de
                interfaces paginadas no cliente.</p>
            <p>Outro ponto positivo √© a ado√ß√£o do <code>ModelMapper</code>, que fizemos na √∫ltima aula, evitando
                mapeamentos manuais repetitivos entre entidades e DTOs, reduzindo o boilerplate e aumentando a
                legibilidade do c√≥digo. Ainda assim, a flexibilidade oferecida pelo <code>ModelMapper</code> permite
                ajustes e personaliza√ß√µes pontuais, como no caso da rela√ß√£o entre <code>Contact</code> e
                <code>Address</code>, em que foi necess√°rio realizar o ‚Äúbind reverso‚Äù para manter a integridade
                relacional.</p>
            <p>O uso do <code>ResponseEntity</code> em todos os m√©todos tamb√©m √© um ponto de destaque. Essa abordagem
                confere √† API mais controle e clareza, permitindo especificar de forma expl√≠cita o c√≥digo de status
                HTTP, cabe√ßalhos adicionais e o corpo da resposta ‚Äî o que √© essencial em cen√°rios mais complexos, como
                tratamento de erros, redirecionamentos ou retornos com metadados.</p>
            <p>A classe tamb√©m est√° documentada com o uso de anota√ß√µes da especifica√ß√£o OpenAPI, como
                <code>@Operation</code> e <code>@ApiResponses</code>. Isso facilita a gera√ß√£o de documenta√ß√£o interativa
                via Swagger UI, tornando a API mais acess√≠vel para desenvolvedores e stakeholders.</p>
            <p>No entanto, apesar da clareza da implementa√ß√£o atual, ainda h√° <strong>melhorias que podem ser
                    introduzidas</strong> para fortalecer ainda mais a arquitetura da aplica√ß√£o. A principal delas √© a
                <strong>separa√ß√£o da l√≥gica de neg√≥cio para uma camada de servi√ßo (<code>@Service</code>)</strong>, o
                que promoveria uma melhor organiza√ß√£o e reutiliza√ß√£o do c√≥digo. Atualmente, o controller executa
                opera√ß√µes como a verifica√ß√£o de exist√™ncia de recursos, salvamento de entidades e manipula√ß√£o direta de
                objetos de dom√≠nio. Com a introdu√ß√£o de uma camada de servi√ßo, o controller se tornaria mais enxuto e
                focado apenas na orquestra√ß√£o das requisi√ß√µes e respostas HTTP, enquanto as regras de neg√≥cio passariam
                a ser encapsuladas de forma reutiliz√°vel e test√°vel. Para evitar tomar mais tempo nesse projeto, visto
                que temos ainda que introduzir conceitos de testes e seguran√ßa, faremos essa separa√ß√£o de camadas em um
                projeto posterior.</p>
            <p>Al√©m disso, a aplica√ß√£o pode evoluir para usar <strong>Spring HATEOAS</strong> (Hypermedia as the Engine
                of Application State), permitindo que as respostas incluam links de navega√ß√£o e a√ß√µes relacionadas ao
                recurso (como &quot;pr√≥xima p√°gina&quot;, &quot;editar&quot;, &quot;excluir&quot;). Essa abordagem
                melhora a <strong>descoberta de recursos</strong> pela API e oferece um ganho significativo na
                usabilidade e autoexplica√ß√£o da interface REST. Al√©m disso, h√° tamb√©m a possibilidade de definir
                <strong>DTOs espec√≠ficos para retorno paginado</strong>, ao inv√©s de expor diretamente a estrutura do
                <code>Page&lt;T&gt;</code>. Essa abordagem melhora a clareza da documenta√ß√£o e permite adicionar
                informa√ß√µes extras ao corpo da resposta, como mensagens personalizadas ou estat√≠sticas agregadas. Al√©m
                disso, isso garantiria que nossas respostas estivessem desacopladas da estrutura interna da
                implementa√ß√£o do <code>Page&lt;T&gt;</code>. Ou seja: mesmo que a estrutura do Spring mude, nossa
                resposta permanece a mesma, garantindo que n√£o quebrar√≠amos nossos clientes.</p>
            <p>Por fim, na nossa <code>AddressController</code> √© necess√°rio aplicar as mesmas melhorias que fizemos na
                <code>ContactController</code>. Para fins pedag√≥gicos, n√£o mostrarei a implementa√ß√£o! Portanto, sua
                tarefa agora √© <strong>fazer as modifica√ß√µes e testar as refatora√ß√µes na
                    <code>AddressController</code>!</strong></p>
            <p>Dito isso, vamos verificar agora como podemos implementar testes na nossa aplica√ß√£o!</p>
            <hr>
            <h2>3. üß™ Testes Automatizados: Unit√°rios e Funcionais</h2>
            <p>Os testes automatizados s√£o uma pr√°tica importante no desenvolvimento de software. Eles garantem que o
                sistema funcione conforme o esperado, facilitando a identifica√ß√£o precoce de falhas e permitindo maior
                confian√ßa durante manuten√ß√µes e evolu√ß√µes da aplica√ß√£o. Nesta fase do projeto, vamos explorar dois tipos
                de testes amplamente utilizados: <strong>testes unit√°rios</strong> e <strong>testes funcionais</strong>,
                entendendo suas diferen√ßas, suas aplica√ß√µes e seus benef√≠cios.</p>
            <p>Os <strong>testes unit√°rios</strong> t√™m como objetivo verificar o comportamento de uma <strong>unidade
                    isolada de c√≥digo</strong>, geralmente um m√©todo ou classe. Em nosso caso, aplicaremos esse tipo de
                teste aos controladores, validando se, por exemplo, o m√©todo <code>getContactById()</code> retorna o DTO
                correto diante de um <code>Contact</code> v√°lido retornado pelo reposit√≥rio. Para isso, simulamos as
                depend√™ncias (como reposit√≥rios e mapeadores) com o uso de <em>mocks</em> via bibliotecas como Mockito,
                e utilizamos a anota√ß√£o <code>@WebMvcTest</code> para carregar apenas o contexto necess√°rio do Spring.
            </p>
            <p>J√° os <strong>testes funcionais</strong> (tamb√©m conhecidos como testes de ponta a ponta ou de integra√ß√£o
                de alto n√≠vel) verificam o <strong>comportamento da aplica√ß√£o como um todo</strong>, a partir da
                perspectiva do cliente. Simulam requisi√ß√µes HTTP reais e validam a resposta completa da API ‚Äî status,
                corpo, headers ‚Äî utilizando ferramentas como o <code>MockMvc</code> ou <code>TestRestTemplate</code>
                combinadas com <code>@SpringBootTest</code>. Isso garante que todas as camadas (controller, service,
                repository) estejam funcionando de forma integrada.</p>
            <p>A grande diferen√ßa entre os dois tipos de teste √© justamente o <strong>n√≠vel de isolamento</strong>:
                enquanto o teste unit√°rio verifica uma pe√ßa de c√≥digo individual em um ambiente controlado, o teste
                funcional executa um fluxo real do sistema em execu√ß√£o. Ambos s√£o importantes e se complementam: o
                primeiro nos d√° precis√£o, o segundo, confian√ßa.</p>
            <p>Um dos principais benef√≠cios dos testes automatizados est√° na <strong>refatora√ß√£o segura do
                    c√≥digo</strong>. Quando queremos melhorar ou modificar uma implementa√ß√£o ‚Äî seja otimizando um
                algoritmo, movendo uma l√≥gica para outro servi√ßo ou alterando um mapeamento de DTO ‚Äî os testes servem
                como uma <strong>rede de seguran√ßa</strong>. Se todos continuarem passando ap√≥s a refatora√ß√£o, sabemos
                que mantivemos o comportamento original intacto. Isso √© ainda mais importante em projetos de m√©dio e
                grande porte, onde mudan√ßas podem impactar m√∫ltiplos pontos do sistema. Lembrem-se das aulas de
                Engenharia de Software, particularmente onde falamos sobre as pr√°ticas de Refatora√ß√£o de C√≥digo Limpo!
            </p>
            <p>Al√©m disso, os testes s√£o cruciais para a <strong>manutenibilidade do software</strong>. Um sistema com
                testes bem escritos se torna mais confi√°vel e f√°cil de evoluir, pois a equipe consegue validar
                rapidamente o impacto de novas funcionalidades ou corre√ß√µes. Eles tamb√©m atuam como uma forma de
                documenta√ß√£o viva, pois expressam de maneira clara e execut√°vel o comportamento esperado de cada
                componente. Dessa forma seu custo de manuten√ß√£o ao longo do ciclo de vida tende a ser bastante
                controlado em rela√ß√£o aos c√≥digos legados que n√£o possuem testes.</p>
            <p>Por isso, nesta etapa do projeto, investiremos tempo para introduzir a implementa√ß√£o de testes ‚Äî tanto
                unit√°rios quanto funcionais ‚Äî cobrindo os cen√°rios positivos e negativos da aplica√ß√£o. Isso</p>
            <p>O objetivo √© garantir que os comportamentos esperados da aplica√ß√£o estejam sempre funcionando
                corretamente, mesmo diante de futuras altera√ß√µes no c√≥digo.</p>
            <p>Podemos sintetizar isso da seguinte forma:</p>
            <table>
                <thead>
                    <tr>
                        <th>Tipo de Teste</th>
                        <th>Foco</th>
                        <th>Exemplo pr√°tico</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Teste Unit√°rio</td>
                        <td>Testar uma unidade isolada</td>
                        <td>Um m√©todo de um controller ou servi√ßo</td>
                    </tr>
                    <tr>
                        <td>Teste Funcional</td>
                        <td>Testar a aplica√ß√£o como um todo</td>
                        <td>Uma chamada HTTP que testa o fluxo completo da API</td>
                    </tr>
                    <tr>
                        <td>Teste de Integra√ß√£o</td>
                        <td>Testar integra√ß√£o entre m√≥dulos</td>
                        <td>O reposit√≥rio conversando com o banco de dados</td>
                    </tr>
                </tbody>
            </table>
            <p>Para essa aula, focaremos em:</p>
            <ul>
                <li><strong>Testes unit√°rios</strong> dos <em>controllers</em></li>
                <li><strong>Testes funcionais</strong> da API, simulando chamadas HTTP</li>
            </ul>
            <p>Esses testes nos ajudar√£o a validar os endpoints, as regras de neg√≥cio, o comportamento dos DTOs e as
                intera√ß√µes com o banco de dados de forma mais robusta.</p>
            <h3>ü§î O que s√£o <strong>mocks?</strong></h3>
            <p>Mocks s√£o como <strong>atores substitutos</strong> em uma pe√ßa de teatro: eles imitam o comportamento de
                outros personagens para que a cena possa ser ensaiada, mesmo quando os atores principais n√£o est√£o
                presentes. Em testes de software, mocks s√£o <strong>objetos falsos</strong> usados para simular o
                comportamento de componentes reais (como um banco de dados, um servi√ßo externo ou um reposit√≥rio) sem
                realmente executar suas funcionalidades.</p>
            <p>Por exemplo, imagine que voc√™ est√° testando uma classe <code>ContactController</code>, que depende de um
                <code>ContactRepository</code> para buscar contatos no banco. Em vez de acessar um banco de dados real,
                voc√™ cria um <strong>mock do reposit√≥rio</strong> que diz: ‚Äúquando algu√©m me perguntar pelo contato com
                ID 1, vou fingir que existe e devolver esse objeto aqui‚Äù. Assim, o foco do teste fica apenas no
                comportamento do controller ‚Äî e <strong>n√£o no banco</strong>.</p>
            <p>Mocks ajudam a deixar os testes <strong>mais r√°pidos, previs√≠veis e isolados</strong>, como se
                estiv√©ssemos testando uma pe√ßa do motor sem precisar ligar o carro todo. Eles s√£o especialmente √∫teis em
                <strong>testes unit√°rios</strong>, onde queremos validar uma classe espec√≠fica sem depender de todo o
                resto da aplica√ß√£o. Para criar esses ‚Äúatores substitutos‚Äù em Java, usamos ferramentas como o
                <strong>Mockito</strong>, que permite dizer exatamente o que o mock deve fazer em cada situa√ß√£o.</p>
            <p>Usar mocks √© uma forma inteligente de garantir que estamos testando <strong>apenas o que
                    importa</strong>, sem efeitos colaterais e sem depender de estruturas externas.</p>
            <h3>Como estruturar nossos testes? üò±</h3>
            <p>Uma das formas mais comuns de estruturarmos nossos testes √© por meio da utiliza√ß√£o da <strong>estrutura
                    Given-When-Then</strong>.</p>
            <p>Essa estrutura √© um padr√£o comum para organizar testes de forma clara e leg√≠vel, inspirado na t√©cnica
                <strong>Behavior-Driven Development (BDD)</strong>. Ela ajuda a separar as fases do teste para que
                qualquer pessoa (inclusive quem n√£o √© desenvolvedor) entenda o que est√° sendo testado. Vamos entender
                cada parte:</p>
            <ul>
                <li>
                    <p><strong>Given</strong> (<em>Dado...</em>) ‚Üí representa o <strong>contexto</strong> inicial do
                        teste. √â onde preparamos o cen√°rio: criamos objetos, configuramos mocks, definimos entradas etc.
                    </p>
                </li>
                <li>
                    <p><strong>When</strong> (<em>Quando...</em>) ‚Üí descreve a <strong>a√ß√£o</strong> que est√° sendo
                        testada. Geralmente √© a chamada de um m√©todo, envio de uma requisi√ß√£o ou invoca√ß√£o de uma
                        opera√ß√£o.</p>
                </li>
                <li>
                    <p><strong>Then</strong> (<em>Ent√£o...</em>) ‚Üí especifica os <strong>resultados esperados</strong>.
                        Aqui usamos <em>assertions</em> para verificar se o comportamento do c√≥digo foi o correto.</p>
                </li>
            </ul>
            <pre><code class="language-java">@Test
void deveRetornarUmContatoQuandoIdForValido() {
    // Given
    Long id = 1L;
    Contact contact = new Contact(&quot;Jo√£o&quot;, &quot;joao@email.com&quot;, &quot;11999999999&quot;);
    ReflectionTestUtils.setField(contact, &quot;id&quot;, id);

    // When
    when(contactRepository.findById(id)).thenReturn(Optional.of(contact));
    ResponseEntity&lt;ContactResponseDTO&gt; response = contactController.getContactById(id);

    // Then
    assertEquals(HttpStatus.OK, response.getStatusCode());
    assertEquals(id, response.getBody().getId());
}
</code></pre>
            <p>Perceba que ao final dos testes usaremos Assertions para verificar os resultados.</p>
            <h3>üß™ <strong>O que s√£o Assertions</strong></h3>
            <p><strong>Assertions</strong> (ou <strong>afirma√ß√µes</strong>) s√£o instru√ß√µes que verificam se o resultado
                de um teste est√° <strong>de acordo com o esperado</strong>. Elas s√£o a parte mais importante do
                <em>Then</em> e dizem: ‚ÄúIsso que aconteceu √© o que eu esperava?‚Äù</p>
            <p>Alguns exemplos com <code>JUnit</code>:</p>
            <pre><code class="language-java">assertEquals(2, resultado); // Verifica se o valor √© 2
assertTrue(lista.isEmpty()); // Verifica se a lista est√° vazia
assertThrows(IllegalArgumentException.class, () -&gt; metodoQueDeveFalhar()); // Verifica se uma exce√ß√£o foi lan√ßada
</code></pre>
            <p>Se uma asser√ß√£o falhar, o teste <strong>falha</strong>, o que indica, portanto, que o c√≥digo n√£o est√° se
                comportando como deveria.</p>
            <h3>Testes como ferramenta de qualidade de entrega cont√≠nua? ‚ôªÔ∏è</h3>
            <p>Quando falamos sobre testes, eles s√£o normalmente executados em:</p>
            <ul>
                <li>
                    <p>Ambiente local, durante o desenvolvimento</p>
                </li>
                <li>
                    <p>Pipelines de integra√ß√£o cont√≠nua (CI), como GitHub Actions, GitLab CI, Jenkins etc., garantindo
                        que o sistema esteja est√°vel antes de realizar deploys</p>
                </li>
            </ul>
            <p>Isso refor√ßa o papel dos testes n√£o s√≥ como ferramenta de desenvolvimento, mas tamb√©m de qualidade de
                entrega cont√≠nua.</p>
            <p>Por hora vamos utilizar os testes apenas em ambiente local, mas futuramente abordaremos o uso dele em
                pipelines de integra√ß√£o cont√≠nua.</p>
            <h3>√â s√≥ isso que preciso saber sobre testes? ü•≥</h3>
            <p>N√£o. Na verdade ainda temos muito a falar: import√¢ncia da cobertura de testes, inser√ß√£o de mutantes para
                QA, organiza√ß√£o do c√≥digo de testes e uso de anota√ß√µes para evitar duplica√ß√£o em nossa base de testes.
            </p>
            <p>De forma geral, o importante √© entender que nossa base de testes tamb√©m precisa estar limpa, assim como
                nossa base de c√≥digo de produ√ß√£o. Dessa forma, ao alterarmos nossa base de c√≥digo para introduzir novas
                features ou modificar features existentes, temos a possibilidade de alterar o c√≥digo de teste de forma
                menos trabalhosa. </p>
            <p>Mais adiante na disciplina abordaremos novamente essas quest√µes. Feitas essas considera√ß√µes, passemos √†
                implementa√ß√£o dos testes!</p>
            <h3>Estrutura de diret√≥rios do nosso projeto üìÇ</h3>
            <p>Quando concluirmos a implementa√ß√£o de nossos testes (ao t√©rmino dessa se√ß√£o), nossa estrutura de
                diret√≥rios ficar√° da maneira vista a seguir:</p>
            <pre><code>‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ main
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ br
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ifsp
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ contacts
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ MapperConfig.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ controller
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îú‚îÄ‚îÄ AddressController.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ ContactController.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ dto
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îú‚îÄ‚îÄ address
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AddressRequestDTO.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AddressResponseDTO.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ contact
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ       ‚îú‚îÄ‚îÄ ContactPatchDTO.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ       ‚îú‚îÄ‚îÄ ContactRequestDTO.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ       ‚îî‚îÄ‚îÄ ContactResponseDTO.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ exception
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îú‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ ResourceNotFoundException.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ model
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îú‚îÄ‚îÄ Address.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ Contact.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ repository
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îú‚îÄ‚îÄ AddressRepository.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ ContactRepository.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ ContactsApiApplication.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ application.properties
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ application-test.properties
‚îÇ   ‚îî‚îÄ‚îÄ test
‚îÇ       ‚îú‚îÄ‚îÄ java
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ br
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ ifsp
‚îÇ       ‚îÇ           ‚îî‚îÄ‚îÄ contacts
‚îÇ       ‚îÇ               ‚îú‚îÄ‚îÄ ContactController
‚îÇ       ‚îÇ               ‚îÇ   ‚îú‚îÄ‚îÄ ContactControllerFunctionalTest.java
‚îÇ       ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ ContactControllerUnitTest.java
‚îÇ       ‚îÇ               ‚îî‚îÄ‚îÄ ContactsApiApplicationTests.java
‚îÇ       ‚îî‚îÄ‚îÄ resources
‚îÇ           ‚îî‚îÄ‚îÄ schema.sql
</code></pre>
            <p>Antes de come√ßar, entretanto, certifique-se de que seu <code>pom.xml</code> tem as depend√™ncias de teste
                (que o Spring Boot j√° inclui por padr√£o):</p>
            <pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
            <h3>Entendendo os arquivos <code>schema.sql</code> e <code>application-test.properties</code></h3>
            <p>A introdu√ß√£o dos arquivos <code>schema.sql</code> e <code>application-test.properties</code> na estrutura
                do projeto, como visto acima, tem como principal objetivo configurar um ambiente de testes isolado,
                confi√°vel e controlado ‚Äî essencial para a execu√ß√£o adequada dos testes funcionais e de integra√ß√£o.</p>
            <p>O arquivo <code>schema.sql</code> √© utilizado para definir explicitamente a estrutura das tabelas do
                banco de dados durante os testes. Ele cont√©m os comandos SQL respons√°veis por criar as tabelas
                necess√°rias (como <code>CONTACT</code> e <code>ADDRESS</code>) com suas colunas, tipos e
                relacionamentos. Quando usamos o banco H2 em mem√≥ria, o Spring precisa de instru√ß√µes claras sobre como
                construir esse esquema, especialmente quando a configura√ß√£o <code>spring.jpa.hibernate.ddl-auto</code>
                est√° desativada. Sem esse arquivo, a aplica√ß√£o pode lan√ßar erros como ‚Äútable not found‚Äù ou apresentar
                falhas de mapeamento JPA ao executar testes que dependem do acesso ao banco. Para garantir que nossos
                testes funcionem, vamos cri√°-lo. </p>
            <p>J√° o <code>application-test.properties</code> √© o arquivo de configura√ß√£o espec√≠fico para o ambiente de
                testes. Ele permite sobrescrever as configura√ß√µes padr√£o da aplica√ß√£o e adaptar o ambiente
                exclusivamente para os testes automatizados. Nele, por exemplo, definimos o uso de um banco H2 em
                mem√≥ria, um driver JDBC espec√≠fico (<code>org.h2.Driver</code>), e evitamos que o Hibernate tente criar
                ou modificar o banco automaticamente (<code>spring.jpa.hibernate.ddl-auto=none</code>). Tamb√©m indicamos
                que o Spring deve utilizar o <code>schema.sql</code> como base para criar o banco de dados ao iniciar os
                testes. Com isso, garantimos que o ambiente seja inicializado sempre da mesma maneira, sem depender de
                configura√ß√µes locais ou de acesso a bancos reais como MySQL ou PostgreSQL - tenha em mente que
                <strong>nunca, sob hip√≥tese alguma, devemos executar nossos testes no banco de dados real de
                    produ√ß√£o</strong>.</p>
            <p>Em conjunto, <code>schema.sql</code> e <code>application-test.properties</code> asseguram que os testes
                rodem de forma independente, previs√≠vel e livre de efeitos colaterais. Isso √© fundamental para garantir
                que os testes automatizados sejam confi√°veis, principalmente em processos de integra√ß√£o cont√≠nua
                (CI/CD), onde testes precisam rodar automaticamente a cada nova entrega de c√≥digo. Se desejarmos, ainda
                √© poss√≠vel complementar esse ambiente adicionando um arquivo <code>data.sql</code> para popular o banco
                com dados iniciais e facilitar os testes em cen√°rios reais! Por hora, entretanto, vamos seguir com a
                implementa√ß√£o maios simples.</p>
            <h3>C√≥digo do <code>schema.sql</code></h3>
            <pre><code class="language-sql">CREATE TABLE contact (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    telefone VARCHAR(15) NOT NULL
);

CREATE TABLE address (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    rua VARCHAR(255) NOT NULL,
    cidade VARCHAR(255) NOT NULL,
    estado VARCHAR(2) NOT NULL,
    cep VARCHAR(9) NOT NULL,
    contact_id BIGINT NOT NULL,
    CONSTRAINT fk_address_contact FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE CASCADE
);
</code></pre>
            <h3>C√≥digo do <code>application-test.properties</code></h3>
            <pre><code class="language-properties">spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
spring.jpa.hibernate.ddl-auto=none
</code></pre>
            <h3>üéØ Testando o ContactController com Testes Unit√°rios: Classe <code>ContactControllerUnitTest.java</code>
            </h3>
            <pre><code class="language-java">package br.ifsp.contacts.ContactController;

@ExtendWith(MockitoExtension.class)
public class ContactControllerUnitTest {

    @Mock
    private ContactRepository contactRepository;

    @Mock
    private ModelMapper modelMapper;

    @InjectMocks
    private ContactController contactController;

    @Test
    void testGetContactById_ReturnsContact() {
            Long id = 1L;      
            Contact contact = new Contact(&quot;Jo√£o&quot;, &quot;joao@email.com&quot;, &quot;11999999999&quot;);
            Address address = new Address();
            address.setRua(&quot;Rua A&quot;);
            address.setCidade(&quot;Cidade A&quot;);
            address.setEstado(&quot;SP&quot;);
            address.setCep(&quot;00000-000&quot;);
            List&lt;Address&gt; addresses = List.of(address);            
            contact.setAddresses(addresses);
            ReflectionTestUtils.setField(contact, &quot;id&quot;, id); // ID via reflex√£o
        
            ContactResponseDTO dto = new ContactResponseDTO();
            dto.setId(id);
            dto.setNome(&quot;Jo√£o&quot;);
            dto.setEmail(&quot;joao@email.com&quot;);
            dto.setTelefone(&quot;11999999999&quot;);
        
            when(contactRepository.findById(id)).thenReturn(Optional.of(contact));
            when(modelMapper.map(contact, ContactResponseDTO.class)).thenReturn(dto);
        
            ResponseEntity&lt;ContactResponseDTO&gt; response = contactController.getContactById(id);
        
            assertEquals(HttpStatus.OK, response.getStatusCode());
            assertEquals(id, response.getBody().getId());
    }

    @Test
    void testGetContactById_NotFound() {
        Long id = 999L;
        when(contactRepository.findById(id)).thenReturn(Optional.empty());
        
        assertThrows(ResourceNotFoundException.class, () -&gt; contactController.getContactById(id));
    }
}
</code></pre>
            <p>Nossa classe <code>ContactControllerUnitTest</code> √© respons√°vel por realizar <strong>testes
                    unit√°rios</strong> no controlador <code>ContactController</code>, utilizando a biblioteca
                <strong>Mockito</strong> para simular as depend√™ncias externas, como o reposit√≥rio de dados
                (<code>ContactRepository</code>) e o <code>ModelMapper</code>. O objetivo aqui √© testar o comportamento
                do m√©todo <code>getContactById()</code> em dois cen√°rios distintos: quando o contato existe e quando ele
                n√£o √© encontrado. Esse tipo de teste isola a l√≥gica da unidade sob teste ‚Äî no caso, o m√©todo do
                controller ‚Äî sem depender de banco de dados real, servidor web ou quaisquer outras partes externas da
                aplica√ß√£o. Perceba que estamos testando APENAS o m√©todo <code>getContactById()</code>. Em uma aplica√ß√£o
                real testar√≠amos todos os m√©todos. Aqui, contudo, para fins de brevidade o teste de um m√©todo √©
                suficiente para exemplificarmos a ideia geral.</p>
            <p>A classe est√° anotada com <code>@ExtendWith(MockitoExtension.class)</code>, que ativa o suporte do
                Mockito no JUnit 5, permitindo que as anota√ß√µes <code>@Mock</code> e <code>@InjectMocks</code> funcionem
                corretamente. A anota√ß√£o <code>@Mock</code> indica que os objetos <code>contactRepository</code> e
                <code>modelMapper</code> s√£o <strong>mocks</strong>, ou seja, substitui√ß√µes falsas dos objetos reais. √â
                importante ressaltar que os <code>mocks</code> s√£o usados no <code>ContactRepository</code> e no
                <code>ModelMapper</code> para simular o comportamento dessas depend√™ncias externas ao ContactController
                durante os testes unit√°rios. Isso permite que testar o controller <strong>isoladamente</strong>, sem
                depender da l√≥gica real do reposit√≥rio nem do mapeamento entre entidades e DTOs. A anota√ß√£o
                <code>@InjectMocks</code> diz ao Mockito para criar uma inst√¢ncia real de
                <code>ContactController</code>, injetando nela os mocks criados. Dessa forma, podemos testar a l√≥gica do
                controller com depend√™ncias controladas.</p>
            <p>Vamos entender isso melhor separadamente:</p>
            <h4>üóÑÔ∏è <code>ContactRepository</code> como Mock</h4>
            <p>O <code>ContactRepository</code> √© a interface respons√°vel por acessar o banco de dados. No teste
                unit√°rio, <strong>n√£o queremos acessar o banco real</strong>, pois:</p>
            <ul>
                <li>Tornaria os testes <strong>mais lentos</strong>;</li>
                <li>Os testes poderiam <strong>falhar por motivos externos</strong> (banco fora do ar, sem dados, etc);
                </li>
                <li>Estar√≠amos testando o banco, e n√£o a l√≥gica do controller.</li>
            </ul>
            <p>Ao usar <code>@Mock</code>, voc√™ diz: </p>
            <blockquote>
                <p>‚ÄúEu vou controlar manualmente o que esse reposit√≥rio retorna quando o m√©todo <code>findById()</code>
                    for chamado.‚Äù</p>
            </blockquote>
            <p>Exemplo:</p>
            <pre><code class="language-java">when(contactRepository.findById(1L)).thenReturn(Optional.of(contact));
</code></pre>
            <p>Com isso, o teste <strong>n√£o consulta o banco</strong>. Ele apenas simula que, ao buscar o ID 1, o
                reposit√≥rio retornaria um contato j√° definido no teste.</p>
            <h4>üîÑ <code>ModelMapper</code> como Mock</h4>
            <p>O <code>ModelMapper</code> faz a convers√£o entre a entidade <code>Contact</code> e o DTO
                <code>ContactResponseDTO</code>. Embora o mapeamento n√£o dependa de banco, ele pode envolver regras
                espec√≠ficas ou lan√ßar exce√ß√µes se houver erros.</p>
            <p>No teste unit√°rio, n√£o queremos verificar <strong>se o mapeamento funciona corretamente</strong> ‚Äî isso
                seria papel de um teste separado (ou j√° √© garantido por testes da pr√≥pria lib).</p>
            <p>Ao usar <code>@Mock</code>, voc√™ evita que o <code>ModelMapper</code> execute a l√≥gica real e garante
                previsibilidade:</p>
            <pre><code class="language-java">when(modelMapper.map(contact, ContactResponseDTO.class)).thenReturn(dto);
</code></pre>
            <p>Assim, voc√™ controla diretamente <strong>qual DTO ser√° retornado</strong>, sem depender da configura√ß√£o
                do mapper.</p>
            <h3>‚úÖ Benef√≠cios de Usar Mocks Aqui</h3>
            <ol>
                <li><strong>Isolamento</strong>: O teste foca exclusivamente no comportamento do controller.</li>
                <li><strong>Velocidade</strong>: Sem conex√£o com banco ou execu√ß√£o de l√≥gica de mapeamento.</li>
                <li><strong>Controle</strong>: Voc√™ define exatamente o que acontece quando m√©todos do mock s√£o
                    chamados.</li>
                <li><strong>Confiabilidade</strong>: O teste n√£o falha por problemas em outras partes do sistema.</li>
            </ol>
            <p>Entendido isso, passemos √† an√°lise de cada um dos m√©todos dessa classe.</p>
            <h3>M√©todo <code>testGetContactById_ReturnsContact()</code></h3>
            <p>Esse m√©todo testa o cen√°rio em que o contato <strong>existe</strong> no reposit√≥rio. Vamos destrinchar as
                etapas do teste:</p>
            <ol>
                <li>
                    <p><strong>Given (cen√°rio)</strong>:</p>
                    <ul>
                        <li>√â criado um <code>Contact</code> com nome, e-mail e telefone.</li>
                        <li>Um <code>Address</code> √© criado e associado a esse contato.</li>
                        <li>O ID do contato √© definido com a ajuda do <code>ReflectionTestUtils.setField()</code>, j√°
                            que o campo <code>id</code> √© privado e n√£o tem <code>setId()</code>.</li>
                        <li>Um <code>ContactResponseDTO</code> (o objeto que deve ser retornado ao cliente) tamb√©m √©
                            configurado com os mesmos dados.</li>
                    </ul>
                </li>
                <li>
                    <p><strong>When (a√ß√£o)</strong>:</p>
                    <ul>
                        <li>√â feito um <code>when().thenReturn()</code> para simular que, ao chamar
                            <code>findById(1L)</code> no reposit√≥rio, ser√° retornado o <code>Contact</code> criado.</li>
                        <li>Tamb√©m se configura que, ao mapear esse <code>Contact</code> com o <code>modelMapper</code>,
                            ser√° retornado o <code>dto</code>.</li>
                    </ul>
                </li>
                <li>
                    <p><strong>Then (verifica√ß√£o)</strong>:</p>
                    <ul>
                        <li>√â chamado <code>getContactById(1L)</code> no controller.</li>
                        <li>O teste verifica se o status HTTP retornado √© 200 OK e se o <code>id</code> retornado no
                            corpo da resposta √© igual ao esperado.</li>
                    </ul>
                </li>
            </ol>
            <p>Esse teste assegura que, <strong>dado um contato existente</strong>, o controller ir√° corretamente
                buscar, mapear e retornar o DTO correspondente.</p>
            <h3>M√©todo <code>testGetContactById_NotFound()</code></h3>
            <p>Esse teste cobre o cen√°rio oposto: quando o contato <strong>n√£o existe</strong>.</p>
            <ol>
                <li>
                    <p><strong>Given</strong>:</p>
                    <ul>
                        <li>Define-se um ID inv√°lido, por exemplo <code>999L</code>.</li>
                        <li>Configura-se o reposit√≥rio para retornar <code>Optional.empty()</code> quando
                            <code>findById(999L)</code> for chamado.</li>
                    </ul>
                </li>
                <li>
                    <p><strong>When/Then</strong>:</p>
                    <ul>
                        <li>Usa-se <code>assertThrows()</code> para verificar se a chamada
                            <code>contactController.getContactById(id)</code> lan√ßa uma exce√ß√£o
                            <code>ResourceNotFoundException</code>.</li>
                    </ul>
                </li>
            </ol>
            <p>Este teste garante que o controller est√° corretamente tratando casos em que o recurso buscado n√£o existe,
                retornando a exce√ß√£o apropriada, o que no contexto da API equivale a um HTTP 404.</p>
            <h3>Em resumo... ‚úçÔ∏è</h3>
            <p>Esses dois testes s√£o exemplos claros de <strong>testes unit√°rios com uso de mocks</strong>. Eles validam
                o comportamento da classe <code>ContactController</code> <strong>sem depender de banco de dados ou do
                    funcionamento real do ModelMapper</strong>. Isso torna os testes r√°pidos, previs√≠veis e focados
                exclusivamente na l√≥gica do controller. Por fim, o uso da estrutura <em>Given-When-Then</em> torna o
                teste mais leg√≠vel e alinhado √†s boas pr√°ticas de desenvolvimento orientado por testes (TDD ou BDD).</p>
            <h3>üéØ Testando o ContactController com Testes Funcionais: Classe
                <code>ContactControllerFunctionalTest.java</code></h3>
            <pre><code class="language-java">package br.ifsp.contacts.ContactController;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles(&quot;test&quot;)
public class ContactControllerFunctionalTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void shouldCreateContactSuccessfully() throws Exception {
        String json = &quot;&quot;&quot;
                    {
                        &quot;nome&quot;: &quot;Maria Oliveira&quot;,
                        &quot;email&quot;: &quot;maria@example.com&quot;,
                        &quot;telefone&quot;: &quot;11988887777&quot;,
                        &quot;addresses&quot;: [
                            {
                                &quot;rua&quot;: &quot;Rua das Rosas&quot;,
                                &quot;cidade&quot;: &quot;Campinas&quot;,
                                &quot;estado&quot;: &quot;SP&quot;,
                                &quot;cep&quot;: &quot;13000-000&quot;
                            }
                        ]
                    }
                &quot;&quot;&quot;;

        mockMvc.perform(post(&quot;/api/contacts&quot;)
                .contentType(&quot;application/json&quot;)
                .content(json))
                .andDo(print()) // &lt;-- aqui exibe a resposta no console
                .andExpect(status().isCreated())
                .andExpect(jsonPath(&quot;$.nome&quot;).value(&quot;Maria Oliveira&quot;))
                .andExpect(jsonPath(&quot;$.email&quot;).value(&quot;maria@example.com&quot;));
    }

    @Test
    void shouldReturnNotFoundWhenContactDoesNotExist() throws Exception {
        mockMvc.perform(get(&quot;/api/contacts/9999&quot;))
                .andExpect(status().isNotFound());
    }
}
</code></pre>
            <p>Nossa classe <code>ContactControllerFunctionalTest</code> √© um exemplo de <strong>teste
                    funcional</strong> constru√≠do para validar o comportamento real da API exposta pelo
                <code>ContactController</code>, simulando chamadas HTTP reais como um cliente faria. Esse tipo de teste
                √© necess√°rio para garantir que o sistema funcione corretamente quando todas as camadas est√£o integradas
                (controller, service, repository e persist√™ncia de dados). Essa classe utiliza a anota√ß√£o
                <code>@SpringBootTest</code> para carregar o contexto completo da aplica√ß√£o, incluindo o banco de dados
                em mem√≥ria (no perfil <code>test</code>), os beans reais e as configura√ß√µes reais de mapeamento.</p>
            <p>O prop√≥sito desses testes, portanto, s√£o bem diferentes dos testes unit√°rios que vimos anteriormente:
                trata-se de validar a <strong>experi√™ncia de uso real da API REST</strong> do sistema, com foco no
                comportamento dos endpoints quando executados de ponta a ponta. Diferente dos testes unit√°rios, aqui n√£o
                usamos mocks das depend√™ncias: o banco √© real (embora em mem√≥ria), o mapeamento via
                <code>ModelMapper</code> est√° em funcionamento e todas as camadas s√£o exercitadas juntas.</p>
            <p>Esses testes s√£o valiosos para detectar falhas de integra√ß√£o, como problemas de mapeamento de DTOs, erros
                na persist√™ncia ou retornos inconsistentes. Quando executados em conjunto com os testes unit√°rios,
                ajudam a garantir a robustez e confiabilidade do sistema. </p>
            <p>Em rela√ß√£o ao seu funcionamento, a anota√ß√£o <code>@AutoConfigureMockMvc</code> permite que o Spring
                injete um objeto <code>MockMvc</code>, que simula requisi√ß√µes HTTP √† aplica√ß√£o sem a necessidade de
                subir um servidor real. A anota√ß√£o <code>@ActiveProfiles(&quot;test&quot;)</code> ativa o perfil de
                teste, garantindo que as configura√ß√µes do <code>application-test.properties</code> (como uso de banco H2
                em mem√≥ria) sejam utilizadas durante a execu√ß√£o dos testes.</p>
            <h3>M√©todo <code>shouldCreateContactSuccessfully</code></h3>
            <p>Este m√©todo testa o <strong>caso positivo de cria√ß√£o de um novo contato via HTTP POST</strong>. Ele
                constr√≥i uma requisi√ß√£o com JSON contendo os campos <code>nome</code>, <code>email</code>,
                <code>telefone</code> e uma lista de endere√ßos. A string JSON √© enviada ao endpoint
                <code>/api/contacts</code> utilizando o m√©todo <code>post</code>, e o conte√∫do da requisi√ß√£o √© definido
                como <code>application/json</code>.</p>
            <p>O m√©todo ent√£o executa a requisi√ß√£o com <code>mockMvc.perform(...)</code> e aplica as seguintes
                valida√ß√µes:</p>
            <ul>
                <li><code>andDo(print())</code>: exibe o conte√∫do da requisi√ß√£o e da resposta no console (√∫til para
                    depura√ß√£o);</li>
                <li><code>andExpect(status().isCreated())</code>: verifica se o status de resposta HTTP √© 201 (Created);
                </li>
                <li><code>andExpect(jsonPath(&quot;$.nome&quot;).value(&quot;Maria Oliveira&quot;))</code>: verifica se
                    o campo <code>nome</code> no corpo da resposta corresponde ao valor enviado;</li>
                <li><code>andExpect(jsonPath(&quot;$.email&quot;).value(&quot;maria@example.com&quot;))</code>: faz a
                    mesma verifica√ß√£o para o campo <code>email</code>.</li>
            </ul>
            <p>Esse teste garante que, quando uma requisi√ß√£o v√°lida √© enviada para criar um contato, o sistema responde
                corretamente com status 201 e os dados retornados s√£o coerentes com os enviados.</p>
            <h3>M√©todo <code>shouldReturnNotFoundWhenContactDoesNotExist</code></h3>
            <p>Este m√©todo verifica o <strong>comportamento do sistema ao tentar buscar um contato inexistente</strong>.
                Ele simula uma chamada HTTP GET para o endpoint <code>/api/contacts/9999</code>, onde o ID 9999 √© um
                n√∫mero arbitr√°rio assumidamente n√£o existente no banco de dados.</p>
            <p>O teste espera que o sistema retorne o status <code>404 Not Found</code>, indicando que o recurso n√£o foi
                encontrado. Isso confirma que o tratamento de exce√ß√µes com <code>ResourceNotFoundException</code> est√°
                funcionando como esperado.</p>
            <h3>üß† Testes Unit√°rios + Funcionais!</h3>
            <p>Nesta etapa, vimos alguns testes automatizados para o <code>ContactController</code>, cobrindo tanto os
                casos esperados quanto os de erro. Com isso, nossa API come√ßa a se aproximar de um projeto profissional:
                funcional, test√°vel e documentada.</p>
            <p>√â importante ressaltar, entretanto, que estamos loooonge de completar todos os testes da aplica√ß√£o. Por
                isso √© importante n√£o negligenciar o desenvolvimento dos testes ao implementarmos nossas features. ü§ì
            </p>
            <hr>
            <h2>4. üìö Conclus√µes da Aula</h2>
            <p>Ao longo da Aula demos mais um passo importante na constru√ß√£o de nossa API REST com Spring Boot, focando
                na <strong>refatora√ß√£o da arquitetura dos controllers</strong>, <strong>melhoria do mapeamento entre
                    entidades e DTOs</strong>, e na <strong>implementa√ß√£o de testes automatizados</strong> para garantir
                a qualidade e previsibilidade do sistema.</p>
            <p>Vamos recapitular os principais pontos abordados:</p>
            <p>Iniciamos a aula realizando a <strong>refatora√ß√£o completa dos controllers</strong> para que passassem a
                retornar objetos do tipo <code>ResponseEntity</code>. Essa mudan√ßa, embora sutil, trouxe vantagens para
                nossa aplica√ß√£o:</p>
            <ul>
                <li>Permitiu o controle mais facilitado sobre o c√≥digo de status HTTP retornado ao cliente
                    (<code>200 OK</code>, <code>201 Created</code>, <code>204 No Content</code>,
                    <code>404 Not Found</code>, etc);</li>
                <li>Facilitou o envio de <strong>headers customizados</strong>, <strong>mensagens
                        personalizadas</strong> e <strong>respostas sem corpo</strong> quando necess√°rio;</li>
                <li>Deixou o c√≥digo mais leg√≠vel e alinhado √†s boas pr√°ticas RESTful modernas;</li>
                <li>Preparou o terreno para futuras melhorias, como a adi√ß√£o de mensagens de erro customizadas, headers
                    de pagina√ß√£o, etc.</li>
            </ul>
            <p>Essa padroniza√ß√£o com <code>ResponseEntity</code> ajuda a manter a <strong>consist√™ncia na comunica√ß√£o
                    com o cliente</strong>, facilitando tanto o consumo da API por sistemas externos quanto a manuten√ß√£o
                da pr√≥pria aplica√ß√£o ao longo do tempo.</p>
            <p>Al√©m disso, melhoramos o mapeamento das entidades e DTOs via <code>ModelMapper</code> em nosso
                <code>ContactController</code>. Isso fez com que nosso c√≥digo ficasse menos verboso e mais claro.</p>
            <p>Por fim, encerramos a aula com a cria√ß√£o de <strong>testes automatizados</strong> ‚Äî tanto
                <strong>unit√°rios</strong> quanto <strong>funcionais</strong> ‚Äî que garantem o bom funcionamento e a
                estabilidade dos principais endpoints da API.</p>
            <p>Realizamos os seguintes testes:</p>
            <ul>
                <li><strong>Testes unit√°rios com MockMvc</strong> para simular requisi√ß√µes HTTP aos controllers,
                    verificando status de resposta, conte√∫do retornado, e integra√ß√£o com os DTOs;</li>
                <li><strong>Testes de caminho feliz</strong>, simulando casos em que os recursos e chamadas s√£o corretas
                    e espera-se resposta de sucesso de nossa API;</li>
                <li><strong>Testes de exce√ß√£o</strong>, simulando casos em que recursos n√£o s√£o encontrados e garantindo
                    que o comportamento da aplica√ß√£o siga o contrato esperado;</li>
            </ul>
            <p>Esses testes aumentam a <strong>confian√ßa no sistema</strong>, facilitam futuras refatora√ß√µes e reduzem o
                risco de regress√µes.</p>
            <h3>üìå Considera√ß√µes Finais</h3>
            <p>Desenvolver APIs RESTful robustas n√£o √© apenas uma quest√£o de fazer os endpoints funcionarem. √â sobre
                projetar aplica√ß√µes com <strong>qualidade t√©cnica, clareza conceitual e boas pr√°ticas
                    consolidadas</strong>. Nesta aula, vimos que uma pequena refatora√ß√£o pode ter impacto na
                manutenibilidade e evolu√ß√£o de um sistema.</p>
            <p>O c√≥digo limpo, os testes bem escritos e a separa√ß√£o de responsabilidades n√£o s√£o luxo ‚Äî s√£o
                <strong>necessidades</strong> em projetos de vida longa. √Ä medida que as aplica√ß√µes crescem, esses
                fundamentos se tornam cada vez mais valiosos.</p>
            <p>Continue investindo nesses princ√≠pios. Eles s√£o o que diferencia um sistema improvisado de um sistema
                profissional. E s√£o o que diferencia um programador iniciante de um bom engenheiro de software.</p>
            <hr>
            <h2>üöÄ Exerc√≠cio para a pr√≥xima aula</h2>
            <p>Vimos muitos conceitos at√© agora. √â hora de solidific√°-los antes de darmos continuidade na disciplina.
                Para isso, vamos fazer um exerc√≠cio pr√°tico! Leia o enunciado abaixo e elabore, em duplas, o exerc√≠cio.
            </p>
            <h3>API de Gerenciamento de Tarefas üë®‚Äçüè≠</h3>
            <p>Voc√™ foi contratado para desenvolver uma <strong>API REST para gerenciamento de tarefas pessoais</strong>
                (to-do list), permitindo que usu√°rios criem, atualizem, consultem e excluam suas tarefas. A API deve ser
                constru√≠da seguindo os princ√≠pios RESTful, utilizar verbos HTTP adequadamente, e implementar
                <strong>pagina√ß√£o</strong>, <strong>valida√ß√µes</strong>, <strong>tratamento de exce√ß√µes</strong>, e
                <strong>testes automatizados</strong> (unit√°rios e funcionais).</p>
            <h3>üìå Regras de Neg√≥cio</h3>
            <ol>
                <li>
                    <p>Cada <strong>tarefa</strong> deve conter:</p>
                    <ul>
                        <li><code>id</code>: identificador √∫nico (gerado automaticamente).</li>
                        <li><code>titulo</code>: texto curto e obrigat√≥rio.</li>
                        <li><code>descricao</code>: texto opcional.</li>
                        <li><code>prioridade</code>: deve ser <code>BAIXA</code>, <code>MEDIA</code> ou
                            <code>ALTA</code>.</li>
                        <li><code>dataLimite</code>: data final para conclus√£o da tarefa.</li>
                        <li><code>concluida</code>: <code>true</code> ou <code>false</code>, indicando se a tarefa j√°
                            foi finalizada.</li>
                        <li><code>categoria</code>: campo textual obrigat√≥rio (ex: ‚Äútrabalho‚Äù, ‚Äúestudo‚Äù, ‚Äúpessoal‚Äù).
                        </li>
                        <li><code>criadaEm</code>: data de cria√ß√£o (preenchida automaticamente).</li>
                    </ul>
                </li>
                <li>
                    <p>N√£o √© permitido criar tarefas com <strong>dataLimite anterior √† data atual</strong>.</p>
                </li>
                <li>
                    <p>Tarefas conclu√≠das <strong>n√£o podem ser editadas ou apagadas</strong> ‚Äî nesse caso, deve ser
                        lan√ßada uma exce√ß√£o com status <strong>409 (Conflict)</strong>.</p>
                </li>
            </ol>
            <h3>üì• Funcionalidades obrigat√≥rias</h3>
            <p>Implemente os seguintes endpoints com seus respectivos verbos HTTP:</p>
            <table>
                <thead>
                    <tr>
                        <th>Verbo</th>
                        <th>Caminho</th>
                        <th>Descri√ß√£o</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>POST</td>
                        <td><code>/api/tasks</code></td>
                        <td>Cria√ß√£o de nova tarefa</td>
                    </tr>
                    <tr>
                        <td>GET</td>
                        <td><code>/api/tasks</code></td>
                        <td>Listar tarefas com pagina√ß√£o</td>
                    </tr>
                    <tr>
                        <td>GET</td>
                        <td><code>/api/tasks/{id}</code></td>
                        <td>Buscar tarefa por ID</td>
                    </tr>
                    <tr>
                        <td>GET</td>
                        <td><code>/api/tasks/search</code></td>
                        <td>Buscar tarefas por categoria (<code>?categoria=...</code>)</td>
                    </tr>
                    <tr>
                        <td>PATCH</td>
                        <td><code>/api/tasks/{id}/concluir</code></td>
                        <td>Marcar tarefa como conclu√≠da</td>
                    </tr>
                    <tr>
                        <td>PUT</td>
                        <td><code>/api/tasks/{id}</code></td>
                        <td>Atualiza√ß√£o completa da tarefa</td>
                    </tr>
                    <tr>
                        <td>DELETE</td>
                        <td><code>/api/tasks/{id}</code></td>
                        <td>Remover tarefa (se ainda n√£o estiver conclu√≠da)</td>
                    </tr>
                </tbody>
            </table>
            <h3>‚ùå Tratamento de Exce√ß√µes</h3>
            <p>Voc√™ dever√° implementar uma classe <code>GlobalExceptionHandler</code> para capturar e retornar respostas
                adequadas para:</p>
            <ul>
                <li><code>ResourceNotFoundException</code>: retorna 404.</li>
                <li><code>InvalidTaskStateException</code>: retorna 409 quando h√° tentativa de modificar tarefas
                    conclu√≠das.</li>
                <li><code>ValidationException</code>: retorna 400 com mensagens amig√°veis.</li>
            </ul>
            <h3>üìÉ Valida√ß√µes</h3>
            <p>Use anota√ß√µes de Bean Validation para validar os campos da entidade e dos DTOs. Exemplo:</p>
            <ul>
                <li><code>titulo</code> e <code>categoria</code> devem ser obrigat√≥rios.</li>
                <li><code>prioridade</code> deve ser um dos valores definidos.</li>
            </ul>
            <h3>üìÑ Pagina√ß√£o</h3>
            <p>O endpoint <code>GET /api/tasks</code> dever√° usar o <code>Pageable</code> do Spring e retornar tarefas
                com suporte a:</p>
            <ul>
                <li>n√∫mero da p√°gina</li>
                <li>tamanho da p√°gina</li>
                <li>ordena√ß√£o por prioridade ou dataLimite</li>
            </ul>
            <h3>‚úÖ Testes Automatizados</h3>
            <p>Implemente <strong>testes unit√°rios</strong> e <strong>testes funcionais</strong> para pelo menos os
                seguintes cen√°rios:</p>
            <ul>
                <li>Criar uma tarefa com dados v√°lidos.</li>
                <li>Tentar criar uma tarefa com <code>dataLimite</code> inv√°lida.</li>
                <li>Buscar tarefa existente por ID.</li>
                <li>Tentar excluir uma tarefa conclu√≠da (e receber erro 409).</li>
                <li>Listar tarefas com pagina√ß√£o.</li>
                <li>Buscar tarefas por categoria.</li>
            </ul>
            <p>Use <code>Mockito</code> e <code>MockMvc</code> (ou <code>TestRestTemplate</code>) conforme o tipo de
                teste.</p>
            <h3>üí° Dicas</h3>
            <ul>
                <li>Use <code>ModelMapper</code> para convers√£o entre DTOs e entidades.</li>
                <li>Mapeie corretamente as enums (<code>@Enumerated</code>).</li>
                <li>B√¥nus: mantenha a l√≥gica de neg√≥cio isolada em uma <strong>camada de servi√ßo</strong>
                    (<code>TaskService</code>).</li>
            </ul>
            <h3>üéØ Objetivos do exerc√≠cio</h3>
            <p>Este exerc√≠cio tem como finalidade consolidar os seguintes conceitos:</p>
            <ul>
                <li>Implementa√ß√£o de API REST com boas pr√°ticas.</li>
                <li>Cria√ß√£o e uso de DTOs.</li>
                <li>Manipula√ß√£o de exce√ß√µes e mensagens amig√°veis.</li>
                <li>Valida√ß√£o de dados com Bean Validation.</li>
                <li>Pagina√ß√£o e ordena√ß√£o de dados.</li>
                <li>Cobertura de testes unit√°rios e funcionais.</li>
            </ul>
            <h2><strong>Bom trabalho e m√£os √† obra! üõ†Ô∏è</strong></h2>
        </div>

    </div>

    <footer class="footer mt-auto py-3">
        <div class="container-fluid">
            <span>
                <p class="text-center text-light">Instituto Federal de Educa√ß√£o, Ci√™ncia e Tecnologia de S√£o Paulo,
                    C√¢mpus
                    Guarulhos. APIs e Microsservi√ßos - Prof. Giovani.</p>
            </span>
        </div>
    </footer>
    </div>


    <script src="js/prism.js"></script>
    <script src="js/jquery.min.js"></script>
    <script src="js/popper.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/main.js"></script>

</body>

</html>