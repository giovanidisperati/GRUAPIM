<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/estilo.css">
    <link rel="stylesheet" href="css/prism.css">

    <title>APIs e Microsservi√ßos - Aula 02 - Continua√ß√£o da Revis√£o de An√°lise e Programa√ß√£o Orientada a Objetos</title>
</head>

<body>
    <div class="wrapper d-flex align-items-stretch">
        <nav id="sidebar">
            <div class="custom-menu">
                <button type="button" id="sidebarCollapse" class="btn btn-primary">
                    <i class="fa fa-bars"></i>
                    <span class="sr-only">Toggle Menu</span>
                </button>
            </div>
            <h1><a href="index.html" class="logo text-center">AULAS</a></h1>
            <ul class="list-unstyled components mb-5">
                <li>
                    <a href="Aula01.html"><span class="mr-1"></span>01 - Revis√£o</a>
                </li>
                <li class="active">
                    <a href="Aula02.html"><span class="mr-0"></span>02 - Revis√£o II</a>
                </li>
                <li>
                    <a href="Aula03.html"><span class="mr-0"></span>03 - REST I</a>
                </li>
                <li>
                    <a href="Aula04.html"><span class="mr-0"></span>04 - REST II</a>
                </li>
                <li>
                    <a href="Aula05.html"><span class="mr-0"></span>05 - REST III</a>
                </li>
                <li>
                    <a href="Aula06.html"><span class="mr-0"></span>06 - REST IV</a>
                </li>
                <li>
                    <a href="Aula07.html"><span class="mr-0"></span>07 - Exerc√≠cio I</a>
                </li>
                <li>
                    <a href="Aula08.html"><span class="mr-0"></span>08 - REST V</a>
                </li>
                <li>
                    <a href="Aula09.html"><span class="mr-0"></span>09 - Microsservi√ßos I</a>
                </li>
                <li>
                    <a href="Aula10.html"><span class="mr-0"></span>10 - Microsservi√ßos II</a>
                </li>
                <li>
                    <a href="Aula11.html"><span class="mr-0"></span>11 - Microsservi√ßos III</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>12 - Microsservi√ßos IV</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>13 - Microsservi√ßos V</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>14 - Microsservi√ßos VI</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>15 - Microsservi√ßos VII</a>
                </li>
            </ul>
        </nav>

        <div id="content" class="p-4 p-md-5 pt-5">











            <h1><strong>Aula 02 - Aprofundando em Java: Lambdas, Streams e Optionals</strong></h1>
<p>Na Aula 01, revisamos a base da Programa√ß√£o Orientada a Objetos em Java. Agora, vamos explorar um conjunto de recursos introduzidos a partir do Java 8 que transformaram a maneira como escrevemos c√≥digo: <strong>Express√µes Lambda, a Stream API e a classe <code>Optional</code></strong>.</p>
<p>Essas ferramentas s√£o o cora√ß√£o do estilo de programa√ß√£o funcional em Java e s√£o usadas extensivamente em frameworks como o Spring Boot. Compreend√™-las n√£o √© apenas um diferencial, mas um requisito para escrever c√≥digo limpo e expressivo.</p>
<p>N√£o se preocupe se alguns conceitos ainda ficarem &quot;nublados&quot; nesse primeiro momento. Os pontos se conectar√£o mais adiante quando os utilizarmos para constru√ß√£o de nossas APIs Rest. üßë‚Äçüíª</p>
<hr>
<h2><strong>1. Mudando a Perspectiva: Uma Introdu√ß√£o √† Programa√ß√£o Funcional</strong></h2>
<p>At√© agora, nossa vis√£o sobre Java foi moldada pela <strong>Programa√ß√£o Orientada a Objetos (POO)</strong>. Na POO, modelamos o mundo como um conjunto de <strong>objetos</strong> que possuem <em>estado</em> (atributos) e <em>comportamento</em> (m√©todos). O foco est√° nos substantivos: um <code>Carro</code>, um <code>Cliente</code>, uma <code>NotaFiscal</code>. Nosso c√≥digo opera modificando o estado desses objetos ao longo do tempo.</p>
<p>Agora, vamos introduzir uma perspectiva diferente, mas complementar: a <strong>Programa√ß√£o Funcional (PF)</strong>.</p>
<p>Na Programa√ß√£o Funcional, em vez de focar em objetos que mudam de estado, pensamos em termos de <strong>transforma√ß√£o de dados</strong>. O software √© visto como uma s√©rie de fun√ß√µes matem√°ticas, onde cada fun√ß√£o recebe uma entrada, processa-a e produz uma sa√≠da, <strong>sem alterar nada fora de seu escopo</strong>. O foco aqui est√° nos verbos: <code>calcular</code>, <code>filtrar</code>, <code>transformar</code>.</p>
<h3><strong>1.1 Os Pilares da Programa√ß√£o Funcional</strong></h3>
<p>Para entender essa abordagem, precisamos conhecer tr√™s conceitos-chave que a sustentam:</p>
<h4><strong>1. Fun√ß√µes como Cidad√£os de Primeira Classe (First-Class Citizens)</strong></h4>
<p>Este √© o pilar central. Significa que as fun√ß√µes s√£o tratadas como qualquer outro valor no programa. Em Java, isso √© alcan√ßado atrav√©s das <strong>Interfaces Funcionais</strong> e <strong>Express√µes Lambda</strong>. Nesse paradigma uma fun√ß√£o pode ser:</p>
<ul>
<li><p><strong>Atribu√≠da a uma vari√°vel:</strong></p>
<pre><code class="language-java">// A fun√ß√£o (x -&gt; x * 2) √© atribu√≠da √† vari√°vel &#39;dobrar&#39;.
// A vari√°vel &#39;dobrar&#39; √© do tipo Function&lt;Integer, Integer&gt;, uma interface funcional.
Function&lt;Integer, Integer&gt; dobrar = x -&gt; x * 2;

// Agora, podemos usar a vari√°vel para executar a fun√ß√£o.
int resultado = dobrar.apply(5); // resultado = 10
</code></pre>
</li>
<li><p><strong>Passada como argumento para outra fun√ß√£o:</strong></p>
<pre><code class="language-java">// Este m√©todo recebe uma lista e uma fun√ß√£o como argumentos.
public static List&lt;Integer&gt; aplicarFuncaoNaLista(List&lt;Integer&gt; lista, Function&lt;Integer, Integer&gt; funcao) {
    List&lt;Integer&gt; novaLista = new ArrayList&lt;&gt;();
    for (Integer item : lista) {
        novaLista.add(funcao.apply(item));
    }
    return novaLista;
}

// No c√≥digo principal, passamos a fun√ß√£o &#39;dobrar&#39; como argumento.
List&lt;Integer&gt; numeros = Arrays.asList(1, 2, 3);
List&lt;Integer&gt; numerosDobrados = aplicarFuncaoNaLista(numeros, dobrar); // [2, 4, 6]
</code></pre>
</li>
<li><p><strong>Retornada como resultado de outra fun√ß√£o:</strong></p>
<pre><code class="language-java">// Este m√©todo retorna uma fun√ß√£o que multiplica por um valor espec√≠fico.
public static Function&lt;Integer, Integer&gt; criarMultiplicador(int multiplicador) {
    return numero -&gt; numero * multiplicador;
}

// Criamos e armazenamos novas fun√ß√µes dinamicamente.
Function&lt;Integer, Integer&gt; triplicar = criarMultiplicador(3);
Function&lt;Integer, Integer&gt; quintuplicar = criarMultiplicador(5);

int resultadoTriplo = triplicar.apply(10);   // resultadoTriplo = 30
int resultadoQuintuplo = quintuplicar.apply(10); // resultadoQuintuplo = 50
</code></pre>
</li>
</ul>
<p>Essa capacidade √© o que abre as portas para as <strong>Express√µes Lambda</strong>, que nada mais s√£o do que uma forma de escrever essas fun√ß√µes &quot;port√°teis&quot;.</p>
<h4><strong>2. Imutabilidade e a Aus√™ncia de Efeitos Colaterais (Side Effects)</strong></h4>
<p>Este √© talvez o maior contraste com a POO tradicional.</p>
<ul>
<li><strong>Efeito Colateral (Side Effect):</strong> √â qualquer altera√ß√£o de estado fora do escopo da fun√ß√£o. Modificar um atributo de um objeto que foi passado como par√¢metro, alterar uma vari√°vel global, escrever em um arquivo ou no console s√£o todos exemplos de efeitos colaterais.</li>
<li><strong>Imutabilidade:</strong> Significa que os dados, uma vez criados, n√£o podem ser alterados. Em vez de modificar uma lista existente, uma fun√ß√£o funcional cria e retorna uma <em>nova</em> lista com as mudan√ßas desejadas.</li>
</ul>
<p>Vamos ver a diferen√ßa na pr√°tica.</p>
<p><strong>Exemplo com Efeito Colateral (abordagem mut√°vel):</strong></p>
<pre><code class="language-java">public void dobrarValores(List&lt;Integer&gt; numeros) {
    // EFEITO COLATERAL: A lista original passada como par√¢metro √© modificada.
    for (int i = 0; i &lt; numeros.size(); i++) {
        numeros.set(i, numeros.get(i) * 2);
    }
}

List&lt;Integer&gt; minhaLista = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));
dobrarValores(minhaLista);
// Agora &#39;minhaLista&#39; foi alterada e cont√©m [2, 4, 6].
// Isso pode ser inesperado e causar bugs em outras partes do c√≥digo que usam &#39;minhaLista&#39;.
</code></pre>
<p><strong>Exemplo Sem Efeitos Colaterais (abordagem imut√°vel e funcional):</strong></p>
<pre><code class="language-java">public List&lt;Integer&gt; dobrarValores(List&lt;Integer&gt; numeros) {
    // SEM EFEITO COLATERAL: A lista original n√£o √© modificada.
    // Uma nova lista √© criada e retornada.
    return numeros.stream()
                  .map(n -&gt; n * 2)
                  .collect(Collectors.toList());
}

List&lt;Integer&gt; minhaLista = Arrays.asList(1, 2, 3);
List&lt;Integer&gt; listaDobrada = dobrarValores(minhaLista);

// &#39;minhaLista&#39; permanece intacta: [1, 2, 3]
// &#39;listaDobrada&#39; cont√©m o novo resultado: [2, 4, 6]
</code></pre>
<p>E isso √© valioso porque c√≥digo sem efeitos colaterais √© mais previs√≠vel. Uma fun√ß√£o, dadas as mesmas entradas, <strong>sempre</strong> produzir√° as mesmas sa√≠das. Isso torna o c√≥digo mais f√°cil de testar, depurar e, especialmente, de paralelizar, pois elimina as condi√ß√µes de corrida (quando m√∫ltiplas threads tentam modificar o mesmo dado ao mesmo tempo).</p>
<h4><strong>3. Programa√ß√£o Declarativa vs. Imperativa</strong></h4>
<p>Este pilar define o estilo de escrita do c√≥digo.</p>
<ul>
<li><strong>Estilo Imperativo (o &quot;como&quot;):</strong> Voc√™ descreve passo a passo <em>como</em> o computador deve executar uma tarefa. La√ßos <code>for</code> e <code>while</code> s√£o a marca registrada desse estilo. Voc√™ controla cada detalhe do fluxo.</li>
<li><strong>Estilo Declarativo (o &quot;o qu√™&quot;):</strong> Voc√™ descreve <em>o que</em> voc√™ quer como resultado, e a linguagem ou API se encarrega dos detalhes da execu√ß√£o.</li>
</ul>
<p>Vejamos um exemplo simples: obter os nomes dos produtos com pre√ßo acima de R$100.</p>
<p><strong>Abordagem Imperativa (foco no &quot;COMO&quot;):</strong></p>
<pre><code class="language-java">List&lt;String&gt; nomesProdutosCaros = new ArrayList&lt;&gt;();
for (Produto produto : listaProdutos) {
    if (produto.getPreco() &gt; 100.0) {
        nomesProdutosCaros.add(produto.getNome());
    }
}
</code></pre>
<p>Aqui, n√≥s instru√≠mos cada passo: crie uma lista vazia, itere sobre a lista original, verifique a condi√ß√£o, adicione √† nova lista.</p>
<p><strong>Abordagem Declarativa (foco no &quot;O QU√ä&quot;):</strong></p>
<pre><code class="language-java">List&lt;String&gt; nomesProdutosCaros = listaProdutos.stream()
    .filter(p -&gt; p.getPreco() &gt; 100.0)
    .map(p -&gt; p.getNome())
    .collect(Collectors.toList());
</code></pre>
<p>Aqui, n√≥s simplesmente declaramos o que queremos: &quot;A partir da lista de produtos, filtre aqueles com pre√ßo maior que 100, mapeie o resultado para seus nomes e colete em uma nova lista&quot;. A <strong>Stream API</strong> cuida do &quot;como&quot; por baixo dos panos.</p>
<h3><strong>1.2 Conectando com o que Voc√™ J√° Sabe: Recurs√£o</strong></h3>
<p>Se voc√™ j√° usou <strong>recurs√£o</strong>, j√° teve um contato com o pensamento funcional. A recurs√£o √© uma t√©cnica cl√°ssica da Programa√ß√£o Funcional para realizar repeti√ß√µes sem usar la√ßos que dependem de vari√°veis de controle mut√°veis (como o <code>int i = 0</code> do <code>for</code>).</p>
<h3><strong>Por que Estamos Aprendendo Isso?</strong></h3>
<p>O Java, a partir da vers√£o 8, abra√ßou fortemente os conceitos da programa√ß√£o funcional. O motivo √© pr√°tico: esse paradigma ajuda a escrever c√≥digo mais <strong>conciso, expressivo e seguro</strong>, especialmente ao lidar com cole√ß√µes de dados e programa√ß√£o concorrente. No desenvolvimento de APIs com Spring Boot, voc√™ usar√° esses conceitos o tempo todo para manipular dados, tratar respostas ass√≠ncronas e escrever l√≥gicas de neg√≥cio de forma mais limpa.</p>
<p>Agora que entendemos a <em>filosofia</em> da programa√ß√£o funcional, vamos analisar as <em>ferramentas</em> que o Java nos oferece para aplic√°-la na pr√°tica. Come√ßaremos pelas <strong>Express√µes Lambda</strong>.</p>
<hr>
<h2><strong>2. Express√µes Lambda: A Revolu√ß√£o da Concis√£o</strong></h2>
<p>Antes do Java 8, tarefas simples como ordenar uma lista com um crit√©rio customizado ou definir um evento de clique exigiam a cria√ß√£o de <strong>classes an√¥nimas internas</strong>, resultando em um c√≥digo verboso.</p>
<p><strong>O problema:</strong></p>
<pre><code class="language-java">// Ordenando uma lista de Strings por tamanho (antes do Java 8)
Collections.sort(nomes, new Comparator&lt;String&gt;() {
    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
</code></pre>
<p>Toda essa estrutura (<code>new Comparator...</code>) existe apenas para passar um √∫nico m√©todo (<code>compare</code>) como l√≥gica.</p>
<p>As <strong>Express√µes Lambda</strong> resolvem isso, permitindo que voc√™ trate funcionalidades como um argumento de m√©todo, ou c√≥digo como dados.</p>
<p><strong>A solu√ß√£o com Lambda:</strong></p>
<pre><code class="language-java">// A mesma ordena√ß√£o, agora com uma express√£o lambda
Collections.sort(nomes, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));
</code></pre>
<p>O c√≥digo faz exatamente a mesma coisa, mas de forma muito mais direta e leg√≠vel. A seguir, vamos detalhar cada parte desse c√≥digo.</p>
<p>Ele utiliza o m√©todo <code>Collections.sort()</code>, que aceita dois par√¢metros:</p>
<h4><strong>1. Primeiro Par√¢metro: <code>nomes</code></strong></h4>
<ul>
<li><strong>O que √©:</strong> √â a <code>List&lt;String&gt;</code> que voc√™ deseja ordenar.</li>
<li><strong>Fun√ß√£o:</strong> √â o alvo da opera√ß√£o de ordena√ß√£o.</li>
</ul>
<h4><strong>2. Segundo Par√¢metro: A Express√£o Lambda</strong></h4>
<ul>
<li><p><strong>O que √©:</strong> √â a l√≥gica de compara√ß√£o, fornecida como uma fun√ß√£o. Ela diz ao m√©todo <code>sort</code> <em>como</em> ele deve decidir qual dos dois elementos vem primeiro.</p>
</li>
<li><p><strong>Fun√ß√£o:</strong> A lambda <code>(s1, s2) -&gt; Integer.compare(s1.length(), s2.length())</code> √© uma implementa√ß√£o concisa da interface funcional <code>Comparator&lt;String&gt;</code>. Vamos quebrar a lambda em partes:</p>
<ul>
<li><p><strong><code>(s1, s2)</code></strong>: Estes s√£o os par√¢metros da fun√ß√£o. Em qualquer momento da ordena√ß√£o, o algoritmo pegar√° dois elementos da lista <code>nomes</code> para comparar, que ser√£o representados por <code>s1</code> e <code>s2</code> (ambos do tipo <code>String</code>).</p>
</li>
<li><p><strong><code>-&gt;</code></strong>: √â o operador que separa os par√¢metros do corpo (a l√≥gica) da fun√ß√£o.</p>
</li>
<li><p><strong><code>Integer.compare(s1.length(), s2.length())</code></strong>: Esta √© a implementa√ß√£o da l√≥gica de compara√ß√£o.</p>
<ul>
<li><code>s1.length()</code>: Pega o comprimento (n√∫mero de caracteres) da primeira String.</li>
<li><code>s2.length()</code>: Pega o comprimento da segunda String.</li>
<li><code>Integer.compare(a, b)</code>: Este m√©todo compara dois inteiros (<code>a</code> e <code>b</code>) e retorna:<ul>
<li>Um n√∫mero <strong>negativo</strong> se <code>a</code> for menor que <code>b</code>.</li>
<li><strong>Zero</strong> se <code>a</code> for igual a <code>b</code>.</li>
<li>Um n√∫mero <strong>positivo</strong> se <code>a</code> for maior que <code>b</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>O algoritmo de ordena√ß√£o do <code>Collections.sort</code> usa esse retorno para organizar a lista, resultando em uma ordena√ß√£o baseada no comprimento das strings, da menor para a maior.</p>
<p>Bem pr√°tico, n√©? üëΩ</p>
<h3><strong>2.1. Anatomia de uma Express√£o Lambda</strong></h3>
<p>Uma lambda √©, basicamente, uma fun√ß√£o an√¥nima. Como vimos no exemplo acima, sua sintaxe √©:
<code>(par√¢metros) -&gt; { corpo da fun√ß√£o }</code></p>
<ul>
<li><strong>Par√¢metros:</strong> Uma lista de par√¢metros de entrada (pode ser vazia). O tipo pode ser omitido se o compilador conseguir inferi-lo.</li>
<li><strong>Seta <code>-&gt;</code>:</strong> Separa os par√¢metros do corpo.</li>
<li><strong>Corpo:</strong> Uma √∫nica express√£o ou um bloco de c√≥digo. Se for uma √∫nica express√£o, o <code>return</code> √© impl√≠cito e as chaves <code>{}</code> s√£o opcionais.</li>
</ul>
<h3><strong>2.2. Interfaces Funcionais: A Base das Lambdas</strong></h3>
<p>Uma express√£o lambda s√≥ pode ser usada em um contexto onde um tipo √© esperado. Pense nesse tipo como um <strong>contrato</strong> ou um <strong>molde</strong> para a lambda. Em Java, esse molde √© sempre uma <strong>Interface Funcional</strong>.</p>
<p>Uma Interface Funcional √© definida por uma regra simples: ela deve conter <strong>apenas um m√©todo abstrato</strong>. √â a assinatura desse √∫nico m√©todo que define o formato que a lambda deve seguir (quais par√¢metros ela recebe e o que ela retorna).</p>
<p>O Java j√° nos fornece um conjunto de interfaces funcionais prontas no pacote <code>java.util.function</code>. Dentre as mais comuns temos:</p>
<h4><strong>1. <code>Predicate&lt;T&gt;</code></strong></h4>
<ul>
<li><strong>Prop√≥sito:</strong> Testar uma condi√ß√£o.</li>
<li><strong>M√©todo abstrato:</strong> <code>boolean test(T t)</code></li>
<li><strong>Contrato:</strong> Recebe um objeto do tipo <code>T</code> e retorna <code>true</code> ou <code>false</code>.</li>
<li><strong>Exemplo de Lambda:</strong><pre><code class="language-java">// Testa se um n√∫mero √© par
Predicate&lt;Integer&gt; isEven = numero -&gt; numero % 2 == 0;
System.out.println(isEven.test(10)); // Sa√≠da: true
</code></pre>
</li>
<li><strong>Uso comum:</strong> Ideal para filtros, como em <code>stream().filter()</code>.</li>
</ul>
<h4><strong>2. <code>Function&lt;T, R&gt;</code></strong></h4>
<ul>
<li><strong>Prop√≥sito:</strong> Transformar um valor de um tipo em outro.</li>
<li><strong>M√©todo abstrato:</strong> <code>R apply(T t)</code></li>
<li><strong>Contrato:</strong> Recebe um objeto do tipo <code>T</code> e retorna um objeto do tipo <code>R</code>.</li>
<li><strong>Exemplo de Lambda:</strong><pre><code class="language-java">// Transforma uma String em seu comprimento (Integer)
Function&lt;String, Integer&gt; getLength = texto -&gt; texto.length();
System.out.println(getLength.apply(&quot;Java&quot;)); // Sa√≠da: 4
</code></pre>
</li>
<li><strong>Uso comum:</strong> Perfeita para mapeamentos, como em <code>stream().map()</code>.</li>
</ul>
<h4><strong>3. <code>Consumer&lt;T&gt;</code></strong></h4>
<ul>
<li><strong>Prop√≥sito:</strong> &quot;Consumir&quot; um valor para executar uma a√ß√£o, sem retornar nada.</li>
<li><strong>M√©todo abstrato:</strong> <code>void accept(T t)</code></li>
<li><strong>Contrato:</strong> Recebe um objeto do tipo <code>T</code> e retorna <code>void</code>.</li>
<li><strong>Exemplo de Lambda:</strong><pre><code class="language-java">// A√ß√£o de imprimir uma String no console
Consumer&lt;String&gt; printText = texto -&gt; System.out.println(texto);
printText.accept(&quot;Ol√°, Mundo!&quot;); // Imprime &quot;Ol√°, Mundo!&quot;
</code></pre>
</li>
<li><strong>Uso comum:</strong> Utilizada em opera√ß√µes terminais que executam algo, como <code>list.forEach()</code>.</li>
</ul>
<h4><strong>4. <code>Supplier&lt;T&gt;</code></strong></h4>
<ul>
<li><strong>Prop√≥sito:</strong> Fornecer/criar um valor sem receber nenhuma entrada.</li>
<li><strong>M√©todo abstrato:</strong> <code>T get()</code></li>
<li><strong>Contrato:</strong> N√£o recebe par√¢metros e retorna um objeto do tipo <code>T</code>.</li>
<li><strong>Exemplo de Lambda:</strong><pre><code class="language-java">// Fornece a data e hora atuais
Supplier&lt;LocalDateTime&gt; now = () -&gt; LocalDateTime.now();
System.out.println(now.get()); 
</code></pre>
</li>
<li><strong>Uso comum:</strong> Para cria√ß√£o de objetos ou fornecimento de valores padr√£o, como em <code>Optional.orElseGet()</code>.</li>
</ul>
<p>A anota√ß√£o <code>@FunctionalInterface</code> pode ser usada para garantir que uma interface cumpra o requisito de ter apenas um m√©todo abstrato. Ela √© opcional, mas funciona como uma <strong>verifica√ß√£o de seguran√ßa</strong> para o compilador e uma <strong>dica clara</strong> para outros desenvolvedores de que a interface foi projetada para ser usada com lambdas. Vejamos como isso funciona.</p>
<h3>Criando sua pr√≥pria Interface Funcional</h3>
<p>Voc√™ pode facilmente criar suas pr√≥prias interfaces funcionais para representar contratos espec√≠ficos do seu neg√≥cio.</p>
<p><strong>Exemplo: Criando um formatador de texto</strong></p>
<p>Vamos supor que precisamos de diferentes formas de formatar uma <code>String</code>. Podemos criar uma interface para isso:</p>
<pre><code class="language-java">@FunctionalInterface
public interface TextFormatter {
    String format(String text);
}
</code></pre>
<ul>
<li><strong>A Regra:</strong> A interface <code>TextFormatter</code> tem apenas um m√©todo abstrato, <code>format(String text)</code>.</li>
<li><strong>A Anota√ß√£o:</strong> <code>@FunctionalInterface</code> garante que, se algu√©m tentar adicionar outro m√©todo abstrato a esta interface, o c√≥digo n√£o compilar√°.</li>
</ul>
<p><strong>Como usar:</strong></p>
<p>Agora, podemos criar diferentes implementa√ß√µes para este contrato usando lambdas:</p>
<pre><code class="language-java">// Implementa√ß√£o 1: Converte para mai√∫sculas
TextFormatter toUpperCase = texto -&gt; texto.toUpperCase();

// Implementa√ß√£o 2: Adiciona &quot;!!!&quot; no final
TextFormatter addExclamation = texto -&gt; texto + &quot;!!!&quot;;

System.out.println(toUpperCase.format(&quot;java&quot;));      // Sa√≠da: JAVA
System.out.println(addExclamation.format(&quot;Aten√ß√£o&quot;)); // Sa√≠da: Aten√ß√£o!!!
</code></pre>
<p><strong>Lembrando: o mais importante aqui √© o conceito!</strong> </p>
<p><code>@FunctionalInterface</code> formaliza a cria√ß√£o de &quot;moldes&quot; para as suas lambdas. N√£o se preocupe em decorar todas as interfaces prontas do Java agora. O fundamental √© entender que, por tr√°s de toda express√£o lambda, existe uma interface funcional definindo o contrato que ela cumpre.</p>
<hr>
<h2><strong>3. Stream API: Processando Cole√ß√µes de Forma Declarativa</strong></h2>
<p>A Stream API √© talvez a adi√ß√£o mais impactante do Java 8. Pense nela como uma <strong>linha de montagem para dados:</strong> voc√™ coloca uma cole√ß√£o de itens em uma ponta, e eles passam por v√°rias esta√ß√µes (filtragem, transforma√ß√£o, ordena√ß√£o) at√© sa√≠rem do outro lado como um resultado final. Ela introduz uma nova forma de processar cole√ß√µes de dados, focando no <strong>&quot;o que fazer&quot;</strong> em vez de <strong>&quot;como fazer&quot;</strong>.</p>
<p>Uma <strong>Stream</strong> n√£o √© uma estrutura de dados, mas sim uma sequ√™ncia de elementos de uma fonte (como uma <code>List</code> ou <code>Set</code>) que suporta opera√ß√µes agregadas.</p>
<p>O trabalho com streams geralmente segue um padr√£o de tr√™s etapas:</p>
<ol>
<li><strong>Fonte (Source):</strong> Obter um stream a partir de uma cole√ß√£o.</li>
<li><strong>Opera√ß√µes Intermedi√°rias (Intermediate Operations):</strong> Transformar o stream (filtrar, mapear, etc.). Essas opera√ß√µes s√£o <em>lazy</em> (pregui√ßosas), ou seja, nada acontece at√© que uma opera√ß√£o terminal seja chamada.</li>
<li><strong>Opera√ß√£o Terminal (Terminal Operation):</strong> Produzir um resultado ou um efeito colateral a partir do stream (coletar em uma lista, calcular uma soma, etc.).</li>
</ol>
<h3>Contexto Pr√°tico: Onde a Stream API Brilha?</h3>
<p>Imagine que voc√™ est√° trabalhando em uma <strong>API para um e-commerce</strong>. A equipe de marketing pediu um novo endpoint: <code>GET /api/produtos/destaques</code>.</p>
<p><strong>A Regra de Neg√≥cio:</strong> Este endpoint deve retornar uma lista contendo apenas os <strong>nomes</strong> dos produtos considerados &quot;premium&quot; (com pre√ßo acima de R$ 500), e esses nomes devem estar em <strong>letras mai√∫sculas</strong> para serem exibidos em um banner promocional no site.</p>
<p>Essa l√≥gica de neg√≥cio pertence √† <strong>camada de Servi√ßo (<code>Service</code>)</strong>. O <code>Controller</code> apenas receber√° a requisi√ß√£o e chamar√° o m√©todo do servi√ßo.</p>
<p>Vamos ver como as duas abordagens se sairiam dentro de um <code>ProductService</code>.</p>
<h4><strong>1. Abordagem Imperativa (Com <code>for</code>)</strong></h4>
<p>No seu <code>ProductService</code>, o m√©todo ficaria assim:</p>
<pre><code class="language-java">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    public List&lt;String&gt; findFeaturedProductNamesImperative() {
        // 1. Busca todos os produtos do banco de dados.
        List&lt;Product&gt; allProducts = productRepository.findAll();

        // 2. Prepara uma lista vazia para armazenar os resultados.
        List&lt;String&gt; featuredNames = new ArrayList&lt;&gt;();

        // 3. Itera sobre cada produto para aplicar a regra de neg√≥cio (o &quot;COMO&quot;).
        for (Product product : allProducts) {
            if (product.getPrice() &gt; 500.0) {
                String upperCaseName = product.getName().toUpperCase();
                featuredNames.add(upperCaseName);
            }
        }

        // 4. Retorna a lista preenchida.
        return featuredNames;
    }
}
</code></pre>
<p>Este c√≥digo funciona, mas ele detalha cada passo mec√¢nico necess√°rio para chegar ao resultado.</p>
<h4><strong>2. Abordagem Declarativa (Com Stream API)</strong></h4>
<p>Usando a Stream API, o mesmo m√©todo fica muito mais direto:</p>
<pre><code class="language-java">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    public List&lt;String&gt; findFeaturedProductNamesFunctional() {
        // 1. Busca todos os produtos do banco.
        List&lt;Product&gt; allProducts = productRepository.findAll();

        // 2. Descreve a transforma√ß√£o desejada (o &quot;O QU√ä&quot;).
        return allProducts.stream()
                .filter(product -&gt; product.getPrice() &gt; 500.0)      // Filtra produtos &#39;premium&#39;
                .map(product -&gt; product.getName().toUpperCase())   // Mapeia para o nome em mai√∫sculas
                .collect(Collectors.toList());                     // Coleta os resultados em uma nova lista
    }
}
</code></pre>
<p>Ou seja, ambos os m√©todos entregam o mesmo resultado. No entanto, em um servi√ßo de uma aplica√ß√£o real, a <strong>abordagem funcional (declarativa)</strong> √© geralmente preferida porque:</p>
<ul>
<li><p><strong>Expressa melhor a inten√ß√£o:</strong> O c√≥digo l√™ como uma descri√ß√£o da regra de neg√≥cio (&quot;pegue os produtos, filtre por pre√ßo, transforme em nome mai√∫sculo&quot;), n√£o como uma s√©rie de instru√ß√µes de baixo n√≠vel.</p>
</li>
<li><p><strong>√â mais concisa e menos propensa a erros:</strong> Menos c√≥digo &quot;boilerplate&quot; (como criar e adicionar a uma lista manualmente) significa menos lugares para bugs se esconderem.</p>
</li>
<li><p><strong>Facilita a manuten√ß√£o:</strong> Se a regra mudar (ex: &quot;agora tamb√©m ordene por nome&quot;), adicionar uma nova opera√ß√£o ao stream (<code>.sorted()</code>) √© trivial.</p>
</li>
</ul>
<p>Dentre as principais opera√ß√µes da Stream API temos:</p>
<ul>
<li><strong><code>filter(Predicate&lt;T&gt;)</code></strong>: Retorna um stream com elementos que correspondem a uma condi√ß√£o.</li>
<li><strong><code>map(Function&lt;T, R&gt;)</code></strong>: Transforma cada elemento de um tipo <code>T</code> para um tipo <code>R</code>.</li>
<li><strong><code>sorted()</code></strong>: Ordena os elementos (usando a ordem natural ou um <code>Comparator</code>).</li>
<li><strong><code>distinct()</code></strong>: Remove elementos duplicados.</li>
<li><strong><code>forEach(Consumer&lt;T&gt;)</code></strong>: Executa uma a√ß√£o para cada elemento (opera√ß√£o terminal).</li>
<li><strong><code>collect(Collector)</code></strong>: Agrupa os resultados em uma cole√ß√£o, como <code>List</code>, <code>Set</code> ou <code>Map</code> (opera√ß√£o terminal).</li>
<li><strong><code>findFirst()</code> / <code>findAny()</code></strong>: Retorna um <code>Optional</code> com o primeiro elemento encontrado (opera√ß√£o terminal).</li>
</ul>
<p>Veremos algumas dessas ao longo do semestre (e nos exerc√≠cios!).</p>
<hr>
<h2><strong>4. A Classe <code>Optional</code>: Tratando a Aus√™ncia de Valor com Eleg√¢ncia</strong></h2>
<p>Um dos erros mais comuns em Java √© o <code>NullPointerException</code>. Ele ocorre quando tentamos usar um membro de uma refer√™ncia de objeto que √© <code>null</code>. A classe <code>Optional&lt;T&gt;</code> foi introduzida para fornecer uma solu√ß√£o de tipo seguro para representar a presen√ßa ou aus√™ncia de um valor.</p>
<p><code>Optional</code> √© um <strong>container</strong>: um objeto que pode ou n√£o conter um valor n√£o nulo. Ele nos for√ßa a pensar sobre o caso em que o valor n√£o est√° presente.</p>
<h3><strong>4.1. Criando um <code>Optional</code></strong></h3>
<p>Existem tr√™s maneiras principais de criar uma inst√¢ncia de <code>Optional</code>, cada uma adequada a um cen√°rio diferente. Entender qual usar √© o primeiro passo para escrever um c√≥digo mais seguro.</p>
<h4><strong>1. <code>Optional.of(valor)</code></strong></h4>
<ul>
<li><p><strong>Quando usar:</strong> Quando voc√™ tem um valor que, por contrato, <strong>voc√™ tem certeza de que n√£o √© nulo</strong>.</p>
</li>
<li><p><strong>Comportamento:</strong> Cria um <code>Optional</code> que &quot;envolve&quot; o seu objeto. Se voc√™ tentar passar <code>null</code> para <code>Optional.of()</code>, ele falhar√° imediatamente (<em>fail-fast</em>) com um <code>NullPointerException</code>. Isso √© √∫til para validar suas pr√≥prias premissas no c√≥digo.</p>
<pre><code class="language-java">// Cen√°rio: Voc√™ acabou de criar um novo objeto. Ele NUNCA ser√° nulo.
User newUser = new User(&quot;Ana&quot;);
Optional&lt;User&gt; userOptional = Optional.of(newUser); // Correto e seguro.

User userNulo = null;
// A linha abaixo lan√ßaria um NullPointerException, protegendo o resto do c√≥digo.
// Optional&lt;User&gt; userNuloOptional = Optional.of(userNulo);
</code></pre>
</li>
</ul>
<h4><strong>2. <code>Optional.ofNullable(valor)</code></strong></h4>
<ul>
<li><p><strong>Quando usar:</strong> Este √© o m√©todo mais seguro e comum. Use-o quando voc√™ est√° lidando com um valor que <strong>pode ser nulo</strong>, como o retorno de um m√©todo de busca ou de um mapa.</p>
</li>
<li><p><strong>Comportamento:</strong> Se o valor fornecido n√£o for nulo, ele o envolve em um <code>Optional</code>. Se o valor for <code>null</code>, ele cria um <code>Optional</code> vazio (<code>Optional.empty()</code>). Este m√©todo <strong>nunca lan√ßa <code>NullPointerException</code></strong>.</p>
<pre><code class="language-java">// Cen√°rio: Buscando um usu√°rio que pode ou n√£o existir em um reposit√≥rio.
// O m√©todo findById pode retornar um User ou null.
User foundUser = userRepository.findById(1L);
Optional&lt;User&gt; userOptional = Optional.ofNullable(foundUser); // Forma segura de lidar com o resultado.
</code></pre>
</li>
</ul>
<h4><strong>3. <code>Optional.empty()</code></strong></h4>
<ul>
<li><p><strong>Quando usar:</strong> Quando voc√™ precisa representar explicitamente a aus√™ncia de um valor. √â frequentemente usado como valor de retorno em m√©todos que podem n√£o encontrar o que procuram.</p>
</li>
<li><p><strong>Comportamento:</strong> Retorna uma inst√¢ncia de <code>Optional</code> que est√° garantidamente vazia.</p>
<pre><code class="language-java">// Cen√°rio: Um m√©todo que retorna um Optional&lt;User&gt;, mas uma valida√ß√£o inicial falha.
public Optional&lt;User&gt; findUser(Long id) {
    if (id &lt;= 0) {
        return Optional.empty(); // Retorna &quot;nada&quot; de forma segura e expl√≠cita.
    }
    // ... continua a l√≥gica de busca ...
    return Optional.ofNullable(userRepository.findById(id));
}
</code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Quando Usar</th>
<th>Comportamento com <code>null</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional.of(obj)</code></td>
<td>Quando <code>obj</code> <strong>n√£o pode</strong> ser nulo.</td>
<td>Lan√ßa <code>NullPointerException</code>.</td>
</tr>
<tr>
<td><code>Optional.ofNullable(obj)</code></td>
<td>Quando <code>obj</code> <strong>pode</strong> ser nulo.</td>
<td>Retorna <code>Optional.empty()</code>.</td>
</tr>
<tr>
<td><code>Optional.empty()</code></td>
<td>Para retornar explicitamente um valor ausente.</td>
<td>N/A (j√° retorna um <code>Optional</code> vazio).</td>
</tr>
</tbody></table>
<h3><strong>4.2. Usando <code>Optional</code> de Forma Segura</strong></h3>
<p>A maneira errada de usar <code>Optional</code> √© simplesmente chamar <code>.get()</code> sem verificar se o valor est√° presente, pois isso pode lan√ßar uma <code>NoSuchElementException</code>.</p>
<p>Para entender o motivo, precisamos pensar na proposta do <code>Optional</code>: ele √© um <strong>contrato</strong> que diz &quot;este container pode ou n√£o ter um valor&quot;. O m√©todo <code>.get()</code> foi projetado para ser a forma mais direta de extrair o valor, mas ele opera sob uma premissa perigosa: ele <strong>assume que o valor existe</strong>.</p>
<p>Quando o <code>Optional</code> est√° vazio, o contrato do m√©todo <code>.get()</code> √© lan√ßar a exce√ß√£o <code>NoSuchElementException</code>. Este √© o seu comportamento esperado.</p>
<p><strong>O problema:</strong> <code>NoSuchElementException</code> √© uma <code>RuntimeException</code> (uma exce√ß√£o n√£o checada). Isso significa que o compilador Java <strong>n√£o obriga voc√™ a trat√°-la</strong> com um bloco <code>try-catch</code>. Se voc√™ chamar <code>.get()</code> em um <code>Optional</code> vazio sem uma verifica√ß√£o pr√©via, e n√£o houver um tratamento de exce√ß√£o, sua aplica√ß√£o ir√° quebrar em tempo de execu√ß√£o.</p>
<p><strong>Exemplo pr√°tico do erro:</strong></p>
<pre><code class="language-java">// Cen√°rio: Buscamos um produto que n√£o existe no banco de dados.
Optional&lt;Product&gt; productOptional = productRepository.findById(999L); // Retorna Optional.empty()

// Tentativa errada de extrair o valor
try {
    Product product = productOptional.get(); // &lt;&lt;-- ISTO VAI LAN√áAR A EXCE√á√ÉO
    System.out.println(&quot;Produto encontrado: &quot; + product.getName());
} catch (NoSuchElementException e) {
    System.err.println(&quot;ERRO: O produto n√£o foi encontrado. A aplica√ß√£o quebrou aqui!&quot;);
    // Em uma API REST, isso resultaria em um erro 500 (Internal Server Error)
    // se n√£o fosse tratado, o que √© uma p√©ssima experi√™ncia para o usu√°rio.
}
</code></pre>
<p>Essencialmente, chamar <code>.get()</code> sem uma verifica√ß√£o (<code>.isPresent()</code>) √© trocar um risco (<code>NullPointerException</code>) por outro (<code>NoSuchElementException</code>), o que n√£o resolve o problema fundamental de lidar com a aus√™ncia de valor.</p>
<p>√â por isso que as formas idiom√°ticas (<code>ifPresent</code>, <code>orElse</code>, <code>orElseThrow</code>, etc.) s√£o prefer√≠veis: elas <strong>for√ßam o desenvolvedor a lidar explicitamente com o caso em que o <code>Optional</code> est√° vazio</strong>, resultando em um c√≥digo mais seguro, robusto e previs√≠vel.</p>
<p><strong>As formas seguras e idiom√°ticas de usar <code>Optional</code> s√£o as seguintes:</strong></p>
<ul>
<li><p><strong><code>ifPresent(Consumer&lt;T&gt;)</code></strong>: Executa uma a√ß√£o somente se o valor estiver presente.</p>
<pre><code class="language-java">Optional&lt;User&gt; user = userRepository.findById(1L);
user.ifPresent(u -&gt; System.out.println(&quot;Usu√°rio encontrado: &quot; + u.getName()));
</code></pre>
</li>
<li><p><strong><code>orElse(T other)</code></strong>: Retorna o valor se presente, sen√£o retorna um valor padr√£o.</p>
<pre><code class="language-java">String username = user.map(User::getName).orElse(&quot;Usu√°rio Padr√£o&quot;);
</code></pre>
</li>
<li><p><strong><code>orElseThrow(Supplier&lt;X&gt; exceptionSupplier)</code></strong>: Retorna o valor se presente, sen√£o lan√ßa uma exce√ß√£o. <strong>Esta √© a forma mais comum em APIs REST.</strong></p>
<pre><code class="language-java">Contact contact = contactRepository.findById(id)
    .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
</code></pre>
</li>
</ul>
<h3><strong>4.3. Cuidado: <code>orElse()</code> vs. <code>orElseGet()</code></strong></h3>
<p><strong>Existe uma diferen√ßa de performance sutil, mas importante, entre <code>orElse()</code> e <code>orElseGet()</code>.</strong></p>
<ul>
<li><strong><code>orElse(valorPadrao)</code></strong>: O <code>valorPadrao</code> √© <strong>sempre</strong> calculado, mesmo que o <code>Optional</code> contenha um valor.</li>
<li><strong><code>orElseGet(supplier)</code></strong>: O <code>supplier</code> (uma lambda) s√≥ √© executado se o <code>Optional</code> estiver vazio.</li>
</ul>
<p><strong>Exemplo:</strong></p>
<pre><code class="language-java">// M√©todo custoso que busca um nome padr√£o no banco de dados
public String getNomePadraoSistema() {
    System.out.println(&quot;Executando m√©todo custoso...&quot;);
    // ...l√≥gica de banco...
    return &quot;Admin&quot;;
}

Optional&lt;String&gt; nomeUsuario = Optional.of(&quot;Ana&quot;);

// Mau uso: o m√©todo custoso ser√° executado desnecessariamente.
String nome1 = nomeUsuario.orElse(getNomePadraoSistema()); 
// Console imprime: &quot;Executando m√©todo custoso...&quot;

// Bom uso: o m√©todo custoso N√ÉO ser√° executado.
String nome2 = nomeUsuario.orElseGet(this::getNomePadraoSistema);
// Console n√£o imprime nada.
</code></pre>
<p><strong>Regra geral:</strong> Se o valor padr√£o for uma constante simples, use <code>orElse()</code>. Se a cria√ß√£o do valor padr√£o for custosa (envolve I/O, c√°lculo, etc.), use <code>orElseGet()</code>. Vejamos abaixo uma tabela comparativa entre esses dois m√©todo.</p>
<h3>Tabela Comparativa: <code>orElse()</code> vs. <code>orElseGet()</code></h3>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th><code>orElse(T valor)</code></th>
<th><code>orElseGet(Supplier&lt;T&gt; supplier)</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Argumento que Aceita</strong></td>
<td>Um valor (<code>T</code>) j√° criado ou uma constante.</td>
<td>Uma fun√ß√£o/lambda (<code>Supplier&lt;T&gt;</code>) que sabe como criar o valor.</td>
</tr>
<tr>
<td><strong>Custo da Opera√ß√£o Padr√£o</strong></td>
<td>O valor padr√£o √© calculado <strong>sempre</strong>, mesmo se o <code>Optional</code> contiver um valor.</td>
<td>A fun√ß√£o para criar o valor padr√£o √© executada <strong>apenas se o <code>Optional</code> estiver vazio</strong>.</td>
</tr>
<tr>
<td><strong>Cen√°rio Ideal</strong></td>
<td>Usar com valores constantes ou objetos que j√° existem e s√£o baratos de obter.</td>
<td>Usar quando a cria√ß√£o do valor padr√£o exige c√°lculo, I/O ou chamadas a outros m√©todos custosos.</td>
</tr>
</tbody></table>
<p>O exemplo abaixo exemplifica novamente os conceitos, para n√£o deixarmos nenhuma d√∫vida sobre quando usar um ou outro. ü§ì</p>
<h3>Mais um exemplo de C√≥digo Pr√°tico</h3>
<p>Imagine que estamos buscando uma configura√ß√£o em um mapa. Se a configura√ß√£o n√£o existir, precisamos obter um valor padr√£o de um m√©todo que simula uma opera√ß√£o lenta (como uma consulta ao banco).</p>
<pre><code class="language-java">import java.util.Map;
import java.util.Optional;

public class OptionalExample {

    // M√©todo que simula uma opera√ß√£o custosa (ex: acesso a banco, chamada de API)
    public static String getExpensiveDefaultValue() {
        System.out.println(&quot;&gt;&gt;&gt; Executando m√©todo custoso para obter valor padr√£o...&quot;);
        // Simula um delay
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;default_value&quot;;
    }

    public static void main(String[] args) {
        Map&lt;String, String&gt; configs = Map.of(&quot;key1&quot;, &quot;value1&quot;);

        System.out.println(&quot;--- Teste com um Optional que cont√©m valor ---&quot;);
        Optional&lt;String&gt; optionalWithValue = Optional.of(&quot;value1&quot;);

        // Usando orElse(): O m√©todo custoso SER√Å chamado desnecessariamente.
        System.out.println(&quot;Usando orElse():&quot;);
        String value1 = optionalWithValue.orElse(getExpensiveDefaultValue());
        System.out.println(&quot;Resultado: &quot; + value1);

        System.out.println(&quot;\n&quot;); // Separador

        // Usando orElseGet(): O m√©todo custoso N√ÉO ser√° chamado.
        System.out.println(&quot;Usando orElseGet():&quot;);
        String value2 = optionalWithValue.orElseGet(() -&gt; getExpensiveDefaultValue()); // ou OptionalExample::getExpensiveDefaultValue
        System.out.println(&quot;Resultado: &quot; + value2);

        System.out.println(&quot;\n--- Teste com um Optional vazio ---&quot;);
        Optional&lt;String&gt; emptyOptional = Optional.empty();

        // Com Optional vazio, ambos chamar√£o o m√©todo, mas orElseGet() continua sendo a pr√°tica mais segura.
        System.out.println(&quot;Usando orElse() com Optional vazio:&quot;);
        String value3 = emptyOptional.orElse(getExpensiveDefaultValue());
        System.out.println(&quot;Resultado: &quot; + value3);
    }
}
</code></pre>
<p><strong>Sa√≠da do C√≥digo:</strong></p>
<pre><code>--- Teste com um Optional que cont√©m valor ---
Usando orElse():
&gt;&gt;&gt; Executando m√©todo custoso para obter valor padr√£o...
Resultado: value1

Usando orElseGet():
Resultado: value1

--- Teste com um Optional vazio ---
Usando orElse() com Optional vazio:
&gt;&gt;&gt; Executando m√©todo custoso para obter valor padr√£o...
Resultado: default_value
</code></pre>
<p>Como o resultado demonstra, <code>orElseGet()</code> evitou a execu√ß√£o desnecess√°ria do m√©todo custoso quando o <code>Optional</code> j√° continha um valor, otimizando a performance da aplica√ß√£o.</p>
<p>Passemos agora a um uso pr√°tico do <code>Optional</code>.</p>
<h3><strong>4.4. Exemplo Pr√°tico: Usando <code>Optional</code> para Conectar Camadas</strong></h3>
<p>Agora que conhecemos as ferramentas, vamos aplic√°-las em um cen√°rio realista. Imagine a estrutura de uma aplica√ß√£o comercial dividida em camadas:</p>
<ul>
<li><strong>Repository:</strong> Respons√°vel por acessar os dados (simularemos um banco em mem√≥ria).</li>
<li><strong>Service:</strong> Onde mora a l√≥gica de neg√≥cio.</li>
<li><strong>Controller:</strong> A porta de entrada que recebe as requisi√ß√µes (simularemos com uma classe <code>main</code>).</li>
</ul>
<p>Nossa tarefa √© criar um m√©todo que atualiza o e-mail de um usu√°rio, mas apenas se o usu√°rio existir e se o novo e-mail for v√°lido. Veja como o <code>Optional</code> cria um contrato seguro e elegante entre essas camadas (lembrando que o c√≥digo-fonte abaixo √© simplificado para fins did√°ticos!).</p>
<h4><strong>Camada 1: O Reposit√≥rio (Simulando o acesso a dados)</strong></h4>
<p>Primeiro, nosso <code>UserRepository</code> simula a busca no banco. Note como ele j√° retorna um <code>Optional</code>, protegendo o resto da aplica√ß√£o desde a fonte dos dados.</p>
<pre><code class="language-java">// Simula uma entidade do banco de dados
class User {
    private Long id;
    private String name;
    private String email;
    // Construtores, Getters e Setters...
    public User(Long id, String name, String email) { this.id = id; this.name = name; this.email = email; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    @Override public String toString() { return &quot;User{id=&quot; + id + &quot;, name=&#39;&quot; + name + &quot;&#39;, email=&#39;&quot; + email + &quot;&#39;}&quot;; }
}

// Simula a classe que acessa o banco de dados
class UserRepository {
    // Um mapa para simular nossa tabela de usu√°rios no banco
    private final Map&lt;Long, User&gt; database = new HashMap&lt;&gt;();

    public UserRepository() {
        // Populando o &quot;banco&quot; com dados iniciais
        database.put(1L, new User(1L, &quot;Ana&quot;, &quot;ana@email.com&quot;));
        database.put(2L, new User(2L, &quot;Carlos&quot;, &quot;carlos@email.com&quot;));
    }

    // O m√©todo de busca j√° retorna um Optional, como faz o Spring Data JPA
    public Optional&lt;User&gt; findById(Long id) {
        return Optional.ofNullable(database.get(id));
    }

    public User save(User user) {
        database.put(user.id, user);
        return user;
    }
}
</code></pre>
<h4><strong>Camada 2: O Servi√ßo (Onde a l√≥gica de neg√≥cio acontece)</strong></h4>
<p>O <code>UserService</code> recebe o <code>UserRepository</code> e usa o <code>Optional</code> para criar um fluxo seguro de valida√ß√£o e atualiza√ß√£o.</p>
<pre><code class="language-java">// Simula a camada de servi√ßo com a l√≥gica de neg√≥cio
class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public Optional&lt;User&gt; updateUserEmail(Long userId, String newEmail) {
        // 1. Busca o usu√°rio. O retorno j√° √© um Optional&lt;User&gt;.
        return userRepository.findById(userId)
                .filter(user -&gt; isEmailValid(newEmail)) // 2. Continua apenas se o email for v√°lido.
                .map(user -&gt; {                          // 3. Se tudo estiver ok, transforma o objeto.
                    user.setEmail(newEmail);
                    return userRepository.save(user);   // 4. Salva e retorna o usu√°rio atualizado.
                });
    }

    private boolean isEmailValid(String email) {
        return email != null &amp;&amp; email.contains(&quot;@&quot;);
    }
}
</code></pre>
<ul>
<li>Aqui buscamos o <code>Optional</code>, filtramos, e mapeamos para a nova vers√£o salva. Se em qualquer ponto o <code>Optional</code> ficar vazio (usu√°rio n√£o encontrado ou e-mail inv√°lido), as opera√ß√µes seguintes s√£o simplesmente ignoradas.</li>
</ul>
<h4><strong>Camada 3: O &quot;Controller&quot; e a Execu√ß√£o (<code>main</code>)</strong></h4>
<p>Finalmente, nossa classe <code>main</code> simula a &quot;requisi√ß√£o&quot; do cliente e mostra como o <code>Controller</code> interpretaria a resposta segura vinda do <code>Service</code>.</p>
<pre><code class="language-java">// Simula a camada que recebe as &quot;requisi√ß√µes&quot;
class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    public String handleUpdateEmailRequest(Long id, String newEmail) {
        // O &quot;Controller&quot; chama o servi√ßo e lida com o Optional retornado.
        return userService.updateUserEmail(id, newEmail)
                .map(user -&gt; &quot;200 OK - Usu√°rio atualizado: &quot; + user.toString()) // Se sucesso, formata a resposta OK.
                .orElse(&quot;404 Not Found - Usu√°rio n√£o encontrado ou email inv√°lido.&quot;); // Se vazio, formata a resposta de erro.
    }
}

// Ponto de entrada da nossa aplica√ß√£o simulada
public class MainApplication {
    public static void main(String[] args) {
        // Inje√ß√£o de depend√™ncia manual: criamos e conectamos as camadas.
        UserRepository userRepository = new UserRepository();
        UserService userService = new UserService(userRepository);
        UserController userController = new UserController(userService);

        // --- Simula√ß√£o das Requisi√ß√µes ---

        // Teste 1: Caso de sucesso
        System.out.println(&quot;Tentativa 1: Atualizando usu√°rio com ID 1...&quot;);
        String response1 = userController.handleUpdateEmailRequest(1L, &quot;ana.nova@email.com&quot;);
        System.out.println(&quot;Resposta: &quot; + response1);
        System.out.println(&quot;--------------------&quot;);

        // Teste 2: Caso de falha (usu√°rio n√£o existe)
        System.out.println(&quot;Tentativa 2: Atualizando usu√°rio com ID 99...&quot;);
        String response2 = userController.handleUpdateEmailRequest(99L, &quot;fantasma@email.com&quot;);
        System.out.println(&quot;Resposta: &quot; + response2);
    }
}
</code></pre>
<p>Este exemplo de ponta a ponta, mesmo sem uso de framework, demonstra o poder do <code>Optional</code>: ele atua como um <strong>contrato seguro entre as camadas</strong>, eliminando a necessidade de verifica√ß√µes de nulo e permitindo a cria√ß√£o de fluxos de dados robustos e declarativos, que s√£o f√°ceis de ler e manter.</p>
<hr>
<h2><strong>5. Method References: &quot;Sintaxe A√ßucarada&quot; para Lambdas</strong></h2>
<p>Em muitos casos, uma express√£o lambda apenas chama um m√©todo existente. As <strong>refer√™ncias de m√©todo (Method References)</strong> s√£o uma sintaxe compacta para esses casos.</p>
<table>
<thead>
<tr>
<th align="left">Tipo de Refer√™ncia</th>
<th align="left">Exemplo Lambda</th>
<th align="left">Exemplo Method Reference</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>M√©todo Est√°tico</strong></td>
<td align="left"><code>str -&gt; Integer.parseInt(str)</code></td>
<td align="left"><code>Integer::parseInt</code></td>
</tr>
<tr>
<td align="left"><strong>M√©todo de Inst√¢ncia (objeto espec√≠fico)</strong></td>
<td align="left"><code>() -&gt; expensiveObject.get()</code></td>
<td align="left"><code>expensiveObject::get</code></td>
</tr>
<tr>
<td align="left"><strong>M√©todo de Inst√¢ncia (objeto arbitr√°rio)</strong></td>
<td align="left"><code>s -&gt; s.toUpperCase()</code></td>
<td align="left"><code>String::toUpperCase</code></td>
</tr>
<tr>
<td align="left"><strong>Construtor</strong></td>
<td align="left"><code>() -&gt; new ArrayList&lt;&gt;()</code></td>
<td align="left"><code>ArrayList::new</code></td>
</tr>
</tbody></table>
<p><strong>Exemplo Pr√°tico:</strong></p>
<p>A atualiza√ß√£o parcial de um contato usava <code>.ifPresent()</code>:</p>
<pre><code class="language-java">// Com lambda
dto.getNome().ifPresent(nome -&gt; existingContact.setNome(nome));

// Com method reference (mais limpo e prefer√≠vel)
dto.getNome().ifPresent(existingContact::setNome);
</code></pre>
<p>Ambas as linhas fazem a mesma coisa, mas a refer√™ncia de m√©todo √© mais expressiva e f√°cil de ler.</p>
<hr>
<h2><strong>Concluindo...</strong></h2>
<p>Entender Lambdas, Streams e Optionals eleva seu c√≥digo Java a um novo patamar de clareza e efici√™ncia. Essas ferramentas representam uma mudan√ßa de paradigma para um estilo mais declarativo e funcional.</p>
<p>Com essa base s√≥lida, estamos agora mais preparados para construir os componentes de nossas APIS com Spring Boot. Voc√™ ver√° como esses recursos tornam o c√≥digo em Controllers, Services e Repositories muito mais enxuto e expressivo.</p>
<p>Mas antes, vamos exercitar esse conceitos com...</p>
<hr>
<h2><strong>Exerc√≠cios ‚öíÔ∏è</strong></h2>
<p>Elabore os exerc√≠cios e o desafio abaixo.</p>
<p>A entrega dever√° ser feita individualmente via Moodle.</p>
<p>Crie uma classe <code>Produto</code> com os atributos: <code>nome</code> (String), <code>preco</code> (double) e <code>categoria</code> (String). As categorias devem ser, pelo menos, &quot;Eletr√¥nicos&quot; e &quot;Livros&quot;. Em uma classe de teste, crie uma <code>List&lt;Produto&gt;</code> com pelo menos 8 produtos de diferentes categorias e pre√ßos, incluindo alguns com a mesma categoria. Ap√≥s isso:</p>
<ul>
<li><p>a. Use <code>forEach</code> e uma estrutura <code>if</code> tradicional para imprimir o nome de todos os produtos da categoria &quot;Eletr√¥nicos&quot;. Em seguida, refa√ßa o mesmo exerc√≠cio usando <code>stream()</code> e a opera√ß√£o <code>filter()</code>.</p>
</li>
<li><p>b. Crie uma nova lista contendo apenas os pre√ßos de todos os produtos cujo pre√ßo seja maior que 500.0. Use as opera√ß√µes <code>filter()</code> e <code>map()</code>. Imprima a lista de pre√ßos.</p>
</li>
<li><p>c. Calcule o valor total do estoque de produtos da categoria &quot;Livros&quot;. Use <code>filter()</code> para selecionar os produtos da categoria correta e, em seguida, use <code>mapToDouble()</code> e <code>sum()</code> para calcular o total.</p>
</li>
<li><p>d. Escreva um m√©todo <code>buscarProdutoPorNome(List&lt;Produto&gt; produtos, String nome)</code> que retorna um <code>Optional&lt;Produto&gt;</code>. Use a Stream API (<code>filter</code> e <code>findFirst</code>).</p>
</li>
<li><p>e. No seu m√©todo <code>main</code>, chame o <code>buscarProdutoPorNome</code>: Primeiro, com um nome de produto que existe. Use <code>ifPresent()</code> para imprimir os detalhes do produto; Depois, com um nome que n√£o existe. Use <code>orElseThrow()</code> para lan√ßar uma <code>RuntimeException</code> com a mensagem &quot;Produto n√£o encontrado!&quot;.</p>
</li>
<li><p>f.  Crie um <code>stream</code> a partir da sua lista de produtos e use <code>.map()</code> para obter uma <code>List&lt;String&gt;</code> contendo apenas os nomes dos produtos. Primeiro, fa√ßa isso com uma express√£o lambda (<code>p -&gt; p.getNome()</code>) e depois refatore para usar uma refer√™ncia de m√©todo (<code>Produto::getNome</code>).</p>
</li>
</ul>
<h2><strong>Desafio - Plataforma de Cursos Online &quot;AcademiaDev&quot;</strong></h2>
<p>A startup de tecnologia educacional <strong>AcademiaDev</strong> est√° lan√ßando sua nova plataforma de cursos online. Seu modelo de neg√≥cio √© baseado em um sistema de assinaturas que d√° aos alunos acesso a um cat√°logo de cursos de alta qualidade, focados no desenvolvimento de software.</p>
<p>Para validar sua proposta de neg√≥cio, a AcademiaDev contratou sua equipe para desenvolver um prot√≥tipo inicial da aplica√ß√£o. Por um infort√∫nio do destino, parte de sua equipe foi hospitalizada ap√≥s a ingest√£o de dezenas de torresmos no Bar do Bigode ao comemorar mais uma vit√≥ria do Corinthians sobre o Palmeiras.</p>
<p>Dessa forma, cabe a voc√™, o(a) √∫nico(a) desenvolvedor(a) <em>gera√ß√£o sa√∫de</em> da equipe, trabalhar na implementa√ß√£o desse prot√≥tipo inicial utilizando todos os conceitos que foram relembrados na Aula 01 e vistos na Aula 02. Nesse prot√≥tipo os requisitos s√£o focados na implementa√ß√£o da l√≥gica de neg√≥cio principal, utilizando um conjunto de dados j√° existente.</p>
<p>Para focar na l√≥gica principal da aplica√ß√£o, <strong>n√£o ser√° necess√°rio implementar as funcionalidades de CRUD completas</strong>. Em vez disso, sua aplica√ß√£o deve iniciar com um conjunto de dados pr√©-cadastrado. Crie uma classe utilit√°ria (ex: <code>InitialData</code>) que popule suas estruturas de dados em mem√≥ria assim que a aplica√ß√£o iniciar. Ou seja, n√£o √© necess√°rio criar um CRUD completo de <code>Courses</code> ou <code>Users</code> - apenas o suficiente para validar a l√≥gica de neg√≥cio.</p>
<p>Nesse sentido, o prot√≥tipo dever√° implementar funcionalidades para:</p>
<ul>
<li>Gerenciamento do cat√°logo de <code>Courses</code> (cursos);</li>
<li>Gerenciamento de <code>Users</code> (usu√°rios) e seus respectivos planos de assinatura;</li>
<li>Sistema de <code>Enrollments</code> (matr√≠culas) e acompanhamento de progresso dos alunos;</li>
<li>Um sistema de fila para atendimento de <code>Support Tickets</code>;</li>
<li>Gera√ß√£o de relat√≥rios e exporta√ß√£o de dados da plataforma.</li>
</ul>
<p>A equipe de analistas da sua empresa, a partir de reuni√µes com os fundadores da AcademiaDev, j√° havia determinado os requisitos a seguir.</p>
<h4><strong>Requisitos Funcionais</strong></h4>
<p><strong>1) Gerenciamento do Cat√°logo de <code>Courses</code></strong>
Os cursos da plataforma devem possuir as seguintes caracter√≠sticas:</p>
<ul>
<li><code>title</code> e <code>description</code>. O <code>title</code> de cada curso deve ser √∫nico na plataforma.</li>
<li><code>instructorName</code>.</li>
<li><code>durationInHours</code> (carga hor√°ria).</li>
<li><code>difficultyLevel</code>, que pode ser <code>BEGINNER</code>, <code>INTERMEDIATE</code> ou <code>ADVANCED</code>.</li>
<li><code>status</code>, que pode ser <code>ACTIVE</code> ou <code>INACTIVE</code>. Um curso com status <code>INACTIVE</code> n√£o pode receber novas matr√≠culas.</li>
</ul>
<p><strong>2) <code>Users</code> e <code>Subscription Plans</code></strong>
Os usu√°rios da plataforma podem pertencer a dois perfis:</p>
<ul>
<li><code>Admin</code>: Possui <code>name</code> e <code>email</code>. Tem permiss√£o para gerenciar o cat√°logo de cursos e usu√°rios.</li>
<li><code>Student</code>: Possui <code>name</code>, <code>email</code> e um <code>subscriptionPlan</code>.</li>
<li>O <code>email</code> de cada usu√°rio (seja <code>Student</code> ou <code>Admin</code>) deve ser √∫nico.</li>
</ul>
<p>Os planos de assinatura (<code>SubscriptionPlan</code>) dispon√≠veis para alunos s√£o:</p>
<ul>
<li><code>BasicPlan</code>: Permite que o aluno esteja matriculado em, no m√°ximo, <strong>3 cursos ativos</strong> simultaneamente.</li>
<li><code>PremiumPlan</code>: Permite que o aluno se matricule em um <strong>n√∫mero ilimitado</strong> de cursos.</li>
</ul>
<p><strong>3) Sistema de <code>Enrollments</code> e <code>Progress</code></strong></p>
<ul>
<li>Um aluno s√≥ pode se matricular em um curso (<code>Course</code>) se o seu plano de assinatura permitir e se o curso estiver com o status <code>ACTIVE</code>.</li>
<li>Ao se matricular em um curso, o progresso (<code>progress</code>) do aluno √© iniciado em 0%.</li>
<li>O sistema deve permitir que um aluno atualize o seu percentual de progresso (0 a 100) em qualquer curso no qual esteja matriculado.</li>
</ul>
<p><strong>4) Fila de Suporte ao <code>User</code></strong></p>
<ul>
<li>Qualquer usu√°rio da plataforma pode abrir um <code>SupportTicket</code>, contendo um <code>title</code> e uma <code>message</code>.</li>
<li>Os tickets devem ser armazenados em uma fila de atendimento para serem processados pela equipe de administradores. O atendimento deve seguir rigorosamente a <strong>ordem de chegada</strong> (FIFO - First-In, First-Out).</li>
</ul>
<p><strong>5) Relat√≥rios e An√°lises da Plataforma</strong>
O sistema deve ser capaz de gerar as seguintes informa√ß√µes anal√≠ticas:</p>
<ul>
<li>Uma lista de cursos pertencentes a um determinado <code>difficultyLevel</code>, <strong>ordenada alfabeticamente</strong> pelo <code>title</code> do curso.</li>
<li>Uma rela√ß√£o de todos os <strong>instrutores √∫nicos</strong> que ministram cursos ativos na plataforma, sem nomes repetidos.</li>
<li>Um relat√≥rio que agrupe os alunos de acordo com seu <code>subscriptionPlan</code>.</li>
<li>O c√°lculo da <strong>m√©dia geral de <code>progress</code></strong>, considerando todas as matr√≠culas de todos os alunos.</li>
<li>A identifica√ß√£o do <strong>aluno com o maior n√∫mero de matr√≠culas</strong> ativas.</li>
<li><strong>Exporta√ß√£o de Dados para CSV:</strong> A plataforma precisa de uma funcionalidade de exporta√ß√£o que permita a um administrador gerar um arquivo CSV a partir de qualquer lista de dados (seja de <code>Courses</code>, <code>Students</code>, etc.). O administrador deve poder <strong>escolher dinamicamente quais colunas (campos) quer no arquivo</strong> no momento da exporta√ß√£o. <strong>Nesse momento, n√£o √© necess√°rio gerar um arquivo <code>.csv</code> f√≠sico: a fun√ß√£o deve apenas retornar e exibir a estrutura do CSV formatada como uma <code>String</code> no console.</strong></li>
</ul>
<h4><strong>Funcionalidades da Aplica√ß√£o (Interface de Linha de Comando)</strong></h4>
<p>A aplica√ß√£o deve ser desenvolvida como um sistema de linha de comando, com um menu que ofere√ßa, no m√≠nimo, as seguintes funcionalidades:</p>
<ol>
<li><p><strong>Opera√ß√µes de Administrador (<code>Admin</code>)</strong></p>
<ul>
<li><strong>Gerenciar Status de Cursos:</strong> Ativar/inativar cursos existentes (n√£o precisa implementar CRUD completo).</li>
<li><strong>Gerenciar Planos de Alunos:</strong> Alterar o plano de assinatura de um aluno existente.</li>
<li><strong>Atender Tickets de Suporte:</strong> Processar tickets da fila em ordem FIFO.</li>
<li><strong>Gerar Relat√≥rios e An√°lises:</strong> Acessar todos os relat√≥rios da plataforma.</li>
<li><strong>Exportar Dados:</strong> Gerar a <code>String</code> CSV com colunas selecion√°veis dinamicamente.</li>
</ul>
</li>
<li><p><strong>Opera√ß√µes do Aluno (<code>Student</code>)</strong></p>
<ul>
<li><strong>Matricular-se em Curso:</strong> Desde que o plano permita e o curso esteja <code>ACTIVE</code>.</li>
<li><strong>Consultar Matr√≠culas:</strong> Ver todos os cursos em que est√° matriculado e seu progresso.</li>
<li><strong>Atualizar Progresso:</strong> Modificar o percentual de conclus√£o de um curso.</li>
<li><strong>Cancelar Matr√≠cula:</strong> Remover-se de um curso (libera vaga para planos b√°sicos).</li>
</ul>
</li>
<li><p><strong>Opera√ß√µes Gerais (Qualquer Usu√°rio):</strong></p>
<ul>
<li><strong>Consultar Cat√°logo de Cursos:</strong> Listar cursos ativos dispon√≠veis.</li>
<li><strong>Abrir Ticket de Suporte:</strong> Criar um novo ticket para a fila de atendimento.</li>
<li><strong>Autentica√ß√£o Simples:</strong> Sistema b√°sico de login por email para distinguir entre Admin e Student. N√£o √© necess√°rio que o usu√°rio tenha senha, apenas o e-mail √© suficiente para autentica√ß√£o. Voc√™ poder√° elaborar duas telas distintas ou simplesmente atribuir papeis aos usu√°rios e fazer a verifica√ß√£o de permiss√£o.</li>
</ul>
</li>
</ol>
<h4><strong>L√≥gica de Neg√≥cio e Regras</strong></h4>
<p>A partir dos requisitos acima, foram destacadas as seguintes regras de neg√≥cio que devem ser consideradas no processo de implementa√ß√£o.</p>
<p><strong>Sistema de Matr√≠culas (<code>Enrollments</code>)</strong></p>
<ul>
<li>Um <code>Student</code> s√≥ pode se matricular em um <code>Course</code> se:<ul>
<li>Seu plano de assinatura permitir (BasicPlan: m√°ximo 3 matr√≠culas ativas).</li>
<li>O curso estiver com status <code>ACTIVE</code>.</li>
<li>N√£o estiver j√° matriculado no mesmo curso.</li>
</ul>
</li>
<li>O progresso inicia em 0% e pode ser atualizado de 0 a 100%.</li>
</ul>
<p><strong>Fila de Suporte</strong></p>
<ul>
<li>Tickets s√£o processados em ordem FIFO (First-In, First-Out).</li>
<li>Qualquer usu√°rio pode abrir tickets, mas apenas <code>Admin</code> pode process√°-los.</li>
</ul>
<p><strong>Relat√≥rios e An√°lises</strong>
O sistema deve gerar as seguintes informa√ß√µes utilizando <strong>Stream API</strong>:</p>
<ul>
<li>Lista de cursos por <code>difficultyLevel</code>, ordenada alfabeticamente.</li>
<li>Rela√ß√£o de instrutores √∫nicos que ministram cursos <code>ACTIVE</code>.</li>
<li>Agrupamento de alunos por <code>subscriptionPlan</code>.</li>
<li>M√©dia geral de progresso de todas as matr√≠culas.</li>
<li>Aluno com maior n√∫mero de matr√≠culas ativas (retorno: <code>Optional&lt;Student&gt;</code>).</li>
</ul>
<h4><strong>Requisitos de Implementa√ß√£o e Ferramentas</strong></h4>
<p>Para este prot√≥tipo, as seguintes ferramentas e abordagens devem ser utilizadas:</p>
<ol>
<li><strong>Persist√™ncia em Mem√≥ria:</strong> Toda a persist√™ncia de dados deve ser simulada em mem√≥ria utilizando as <strong>Collections do Java</strong>. N√£o √© necess√°rio usar um banco de dados real.</li>
<li><strong>Estruturas de Dados Espec√≠ficas:</strong><ul>
<li>Para garantir a unicidade e a busca eficiente de <code>Courses</code> por <code>title</code> e <code>Users</code> por <code>email</code>, utilize a interface <code>Map</code>.</li>
<li>Para a listagem de <code>instructors</code> √∫nicos no relat√≥rio, utilize a interface <code>Set</code>.</li>
<li>Para a fila de <code>Support Tickets</code>, utilize uma implementa√ß√£o da interface <code>Queue</code> (como <code>LinkedList</code> ou <code>ArrayDeque</code>) para garantir o comportamento FIFO.</li>
</ul>
</li>
<li><strong>Programa√ß√£o Funcional com Java 8+:</strong><ul>
<li>Todos os relat√≥rios e an√°lises descritos devem ser implementados utilizando a <strong>Stream API</strong> e <strong>Express√µes Lambda</strong>.</li>
<li>Refor√ßando: a fun√ß√£o que busca o aluno com mais matr√≠culas deve obrigatoriamente retornar um <code>Optional&lt;Student&gt;</code> para tratar o caso de n√£o haver alunos.</li>
</ul>
</li>
<li><strong>Reflection e Anota√ß√µes:</strong><ul>
<li>A funcionalidade de <strong>Exporta√ß√£o de Dados para CSV</strong> deve ser implementada de forma gen√©rica. Crie uma classe utilit√°ria <code>GenericCsvExporter</code> que utilize <strong>Reflection</strong> para ler os campos de qualquer lista de objetos e gerar uma String no formato CSV.</li>
</ul>
</li>
<li><strong>Tratamento de exce√ß√µes:</strong><ul>
<li>Opera√ß√µes que violem regras de neg√≥cio (por exemplo, a tentativa de matricular um <code>Student</code> com <code>BasicPlan</code> no quarto curso, ou em um curso <code>INACTIVE</code>) devem lan√ßar exce√ß√µes customizadas (ex: <code>EnrollmentException</code>). A interface com o usu√°rio deve capturar essas exce√ß√µes e exibir uma mensagem de erro amig√°vel.</li>
</ul>
</li>
<li><strong>Modelagem impl√≠cita:</strong><ul>
<li>Voc√™ notar√° que o conceito de &quot;matr√≠cula&quot; (<code>Enrollment</code>) √© central para o sistema, pois conecta <code>Student</code> e <code>Course</code> e armazena o <code>progress</code>. No entanto, os atributos e a estrutura exata dessa classe n√£o foram detalhados pela sua equipe. Voc√™ dever√° modelar essa classe de associa√ß√£o, definindo os campos e m√©todos necess√°rios para que todas as regras de neg√≥cio de matr√≠cula, cancelamento e progresso funcionem corretamente. Sinta-se √† vontade para criar outras classes de suporte que julgar necess√°rias para uma boa organiza√ß√£o e para cumprir os requisitos. Caso perceba alguma lacuna, voc√™ poder√° complet√°-la como julgar melhor, j√° que o restante de sua equipe est√° hospitalizada.</li>
</ul>
</li>
</ol>
<h4><strong>Modelagem da Solu√ß√£o</strong></h4>
<p>Para implementar a aplica√ß√£o, utilize conceitos da Programa√ß√£o Orientada a Objetos (POO) com Java, incluindo:</p>
<ul>
<li><strong>Encapsulamento</strong> - Para garantir que os dados dos objetos sejam acessados de forma segura e controlada.</li>
<li><strong>Heran√ßa</strong> - Para modelar os diferentes tipos de usu√°rios, se julgar apropriado.</li>
<li><strong>Polimorfismo</strong> - Para permitir o tratamento gen√©rico de diferentes entidades, como os planos de assinatura.</li>
<li><strong>Classes Abstratas e Interfaces</strong> - Para estruturar a hierarquia de suas classes de forma coesa e flex√≠vel.</li>
</ul>
<p>Al√©m da implementa√ß√£o do c√≥digo, elabore um <strong>Diagrama de Classes UML</strong> que represente a estrutura do sistema, demonstrando as rela√ß√µes entre as classes (<code>User</code>, <code>Student</code>, <code>Admin</code>, <code>Course</code>, <code>SubscriptionPlan</code>, <code>Enrollment</code>, etc.). Entregue juntamente com o diagrama uma <strong>justificativa para suas escolhas de design</strong> do prot√≥tipo.</p>
<p>Esse exerc√≠cio poder√° ser feito em duplas.</p>
<h1><strong>M√£os √† obra! ‚öíÔ∏è</strong></h1>


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
            </div>






















    </div>

    <footer class="footer mt-auto py-3">
        <div class="container-fluid">
            <span>
                <p class="text-center text-light">Instituto Federal de Educa√ß√£o, Ci√™ncia e Tecnologia de S√£o Paulo,
                    C√¢mpus Guarulhos. APIs e Microsservi√ßos - Prof. Giovani.</p>
            </span>
        </div>
    </footer>


    <script src="js/prism.js"></script>
    <script src="js/jquery.min.js"></script>
    <script src="js/popper.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/main.js"></script>

</body>

</html>