<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/estilo.css">
    <link rel="stylesheet" href="css/prism.css">

    <title>APIs e Microsservi√ßos - Aula 04 - REST II: Refinando e Aprimorando a API REST com Spring Boot</title>
</head>

<body>
    <div class="wrapper d-flex align-items-stretch">
        <nav id="sidebar">
            <div class="custom-menu">
                <button type="button" id="sidebarCollapse" class="btn btn-primary">
                    <i class="fa fa-bars"></i>
                    <span class="sr-only">Toggle Menu</span>
                </button>
            </div>
            <h1><a href="#" class="logo text-center">GRUAPIM</a></h1>
            <ul class="list-unstyled components mb-5">
                <li>
                    <a href="Aula01.html"><span class="mr-1"></span>01 - Revis√£o</a>
                </li>
                <li>
                    <a href="Aula02.html"><span class="mr-0"></span>02 - Revis√£o II</a>
                </li>
                <li>
                    <a href="Aula03.html"><span class="mr-0"></span>03 - REST I</a>
                </li>
                <li class="active">
                    <a href="Aula04.html"><span class="mr-0"></span>04 - REST II</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>05 - REST III</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>06 - REST IV</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>07 - Exerc√≠cio I</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>08 - Exerc√≠cio II</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>09 - Docker</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>10 - Microsservi√ßos I</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>11 - Microsservi√ßos II</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>12 - Microsservi√ßos III</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>13 - Microsservi√ßos IV</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>14 - Microsservi√ßos V</a>
                </li>
                <li>
                    <a href="#"><span class="mr-0"></span>15 - Microsservi√ßos VI</a>
                </li>
            </ul>
        </nav>


        <div id="content" class="p-4 p-md-5 pt-5">
            <h1><strong>Aula 04 - REST II: Refinando e Aprimorando a API REST com Spring Boot</strong></h1>
            <hr>
            <p>Nesta aula, vamos dar continuidade ao desenvolvimento da nossa API REST criada na aula anterior. O foco
                ser√° na aplica√ß√£o de boas pr√°ticas, tratamento de erros, pagina√ß√£o, ordena√ß√£o, versionamento e
                documenta√ß√£o autom√°tica com Swagger.</p>
            <p>Vamos iniciar a abordar os temas por meio da implementa√ß√£o dos exerc√≠cios e desafios da aula anterior.
                Tenha aten√ß√£o ao replicar os c√≥digos-fontes mostrados abaixo, pois para fins de brevidade os
                <code>import</code> das depend√™ncias das classes foram omitidos.</p>
            <hr>
            <h2>1. M√©todos customizados na JPA</h2>
            <p>No exerc√≠cio 1 da Aula 03, foi pedida a cria√ß√£o de um novo endpoint GET em <code>ContactController</code>
                que permitisse buscar contatos pelo nome.</p>
            <p>Para cumprirmos esse requisito podemos implementar um m√©todo <strong>searchContactsByName</strong> no
                <code>ContactController</code>. A ideia dessa implementa√ß√£o √© criar um endpoint GET que recebe o nome
                como um par√¢metro de URL e retorne uma lista de contatos cujos nomes correspondem parcial ou totalmente
                ao termo pesquisado. Isso √© √∫til para implementarmos funcionalidades de busca mais flex√≠veis e
                din√¢micas. O m√©todo √© demonstrado abaixo.</p>
            <pre><code class="language-java">@GetMapping(&quot;/search&quot;)
public List&lt;Contact&gt; searchContactsByName(@RequestParam String name) {
    return contactRepository.findByNomeContainingIgnoreCase(name);
}
</code></pre>
            <p>Perceba que o m√©todo encapsula a chamada √† <strong>findByNomeContainingIgnoreCase</strong>, no
                <code>ContactRepository</code>.</p>
            <p>O Spring Data JPA fornece a possibilidade de criar m√©todos personalizados na interface de reposit√≥rio
                atrav√©s de <strong>Conven√ß√µes de Nomes (Naming Conventions)</strong>. Essa abordagem permite criar
                consultas complexas apenas definindo m√©todos que sigam um padr√£o de nomenclatura espec√≠fico.</p>
            <p>Assim, para implementar o m√©todo de busca, podemos adicionar o seguinte c√≥digo na interface
                <code>ContactRepository</code>:</p>
            <pre><code class="language-java">public interface ContactRepository extends JpaRepository&lt;Contact, Long&gt; {
    List&lt;Contact&gt; findByNomeContainingIgnoreCase(String nome);
}
</code></pre>
            <h4>üîç <strong>1.1 Como funciona essa Conven√ß√£o de Nomes?</strong></h4>
            <p>A cria√ß√£o de m√©todos customizados se d√° pela defini√ß√£o de nomes que indicam ao Spring Data JPA qual
                consulta deve ser gerada. Isso √© feito utilizando palavras-chave espec√≠ficas que indicam o crit√©rio de
                busca. Alguns exemplos comuns s√£o:</p>
            <ul>
                <li><code>findBy</code>: Indica que o m√©todo ser√° usado para realizar uma busca.</li>
                <li><code>Nome</code>: O nome do atributo que ser√° utilizado na busca. Neste caso, <code>Nome</code>
                    refere-se ao atributo <code>nome</code> da classe <code>Contact</code>.</li>
                <li><code>Containing</code>: Indica que a busca deve procurar ocorr√™ncias que contenham o termo
                    especificado. √â equivalente a um <code>LIKE %termo%</code> em SQL.</li>
                <li><code>IgnoreCase</code>: Indica que a busca deve ignorar mai√∫sculas e min√∫sculas.</li>
            </ul>
            <p>Essa conven√ß√£o √© poderosa e nos permite criar consultas como:</p>
            <ul>
                <li><code>findByNome(String nome)</code> ‚Üí Busca contatos pelo nome exato.</li>
                <li><code>findByNomeAndEmail(String nome, String email)</code> ‚Üí Busca contatos que correspondem a ambos
                    os crit√©rios.</li>
                <li><code>findByNomeOrEmail(String nome, String email)</code> ‚Üí Busca contatos que correspondem a pelo
                    menos um dos crit√©rios.</li>
                <li><code>findByNomeStartingWith(String prefix)</code> ‚Üí Busca contatos cujos nomes come√ßam com
                    determinado prefixo.</li>
                <li><code>findByNomeEndingWith(String sufix)</code> ‚Üí Busca contatos cujos nomes terminam com
                    determinado sufixo.</li>
            </ul>
            <h3>üìå <strong>1.2 M√©todos Personalizados sem Conven√ß√µes de Nome</strong></h3>
            <p>Caso queiramos implementar um m√©todo que n√£o siga essas conven√ß√µes, podemos usar anota√ß√µes
                <code>@Query</code>. Isso √© √∫til quando precisamos de consultas mais complexas ou espec√≠ficas.</p>
            <p>Exemplo com HQL:</p>
            <pre><code class="language-java">import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

@Query(&quot;SELECT c FROM Contact c WHERE LOWER(c.nome) LIKE LOWER(CONCAT(&#39;%&#39;, :nome, &#39;%&#39;))&quot;)
List&lt;Contact&gt; searchByName(@Param(&quot;nome&quot;) String nome);
</code></pre>
            <p>Esse m√©todo produz o mesmo resultado que <code>findByNomeContainingIgnoreCase</code>, mas oferece mais
                controle sobre a query e permite escrever SQL/HQL diretamente. Tamb√©m √© poss√≠vel utilizar SQL nativo com
                <code>nativeQuery = true</code>.</p>
            <p>Exemplo com SQL nativo:</p>
            <pre><code class="language-java">public interface ContactRepository extends JpaRepository&lt;Contact, Long&gt; {

    @Query(value = &quot;SELECT * FROM Contact WHERE LOWER(nome) LIKE LOWER(CONCAT(&#39;%&#39;, :nome, &#39;%&#39;))&quot;, nativeQuery = true)
    List&lt;Contact&gt; searchByName(@Param(&quot;nome&quot;) String nome);
}
</code></pre>
            <h4>üìå 1.3 Como funciona?</h4>
            <ul>
                <li>A anota√ß√£o <code>@Query</code> define a consulta SQL nativa usando o par√¢metro
                    <code>nativeQuery = true</code>.</li>
                <li>Neste exemplo, estamos fazendo um <code>LIKE</code> que ignora mai√∫sculas e min√∫sculas
                    (<code>LOWER()</code>) e busca contatos que contenham o nome informado em qualquer parte do nome.
                </li>
                <li>√â importante usar o nome exato da tabela (<code>Contact</code>) como ela existe no banco de dados.
                </li>
            </ul>
            <p>Este m√©todo fornece controle total sobre a query e √© √∫til quando precisamos usar recursos espec√≠ficos do
                banco de dados que n√£o s√£o suportados diretamente pelo JPA.</p>
            <h4>üìñ <strong>1.4 Quando usar cada abordagem:</strong></h4>
            <ul>
                <li><strong>Conven√ß√£o de Nomes:</strong> Para consultas simples e padr√£o, como busca por atributos
                    espec√≠ficos (<code>findByNome</code>, <code>findByEmail</code>).</li>
                <li><strong>@Query:</strong> Para consultas complexas com relacionamentos entre m√∫ltiplas entidades, ou
                    quando precisamos de controle total sobre a query.</li>
            </ul>
            <h4>üìå <strong>1.5 Exemplo de Requisi√ß√£o:</strong></h4>
            <pre><code>GET /api/contacts/search?name=joao
</code></pre>
            <p>Isso retornar√° todos os contatos cujo nome contenha a palavra <code>joao</code> em qualquer parte do
                nome, ignorando mai√∫sculas e min√∫sculas.</p>
            <hr>
            <h2>2. Implementa√ß√£o do M√©todo PATCH e Tratamento de Exce√ß√µes</h2>
            <p>Para darmos continuidade ao conte√∫do e abordarmos o tratamento de exce√ß√µes, relembremos o Exerc√≠cio 02 da
                Aula 03, que solicitava a cria√ß√£o de um novo m√©todo PATCH que permitisse atualizar parcialmente um
                contato sem precisar enviar todos os dados - o que √© √∫til quando o cliente deseja modificar apenas um ou
                mais atributos espec√≠ficos de um contato, mantendo os demais inalterados. Caso o ID submetido pelo
                cliente na requisi√ß√£o n√£o fosse encontrado, entretanto, era necess√°rio lan√ßar uma exce√ß√£o e retornar o
                status 404 - n√£o encontrado.</p>
            <p>Para cumprir parcialmente esse requisito, podemos podemos prosseguir com a implementa√ß√£o do m√©todo PATCH
                na classe <code>ContactController</code>, por meio do m√©todo <code>updateContactPartial</code>, que
                recebe um ID e um <code>Map&lt;String, String&gt;</code> contendo os campos a serem atualizados.</p>
            <pre><code class="language-java">@PatchMapping(&quot;/{id}&quot;)
public Contact updateContactPartial(@PathVariable Long id, @RequestBody Map&lt;String, String&gt; updates) {
    Contact contact = contactRepository.findById(id)
            .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

    updates.forEach((key, value) -&gt; {
        switch (key) {
            case &quot;nome&quot;:
                contact.setNome(value);
                break;
            case &quot;telefone&quot;:
                contact.setTelefone(value);
                break;
            case &quot;email&quot;:
                contact.setEmail(value);
                break;
        }
    });

    return contactRepository.save(contact);
}
</code></pre>
            <h3>üîç <strong>2.1 Explica√ß√£o do C√≥digo:</strong></h3>
            <ol>
                <li>
                    <p><strong>Recebimento do ID do Contato:</strong> </p>
                    <ul>
                        <li>A URL da requisi√ß√£o especifica o ID do contato a ser modificado
                            (<code>/api/contacts/{id}</code>).</li>
                        <li>Se o contato n√£o for encontrado no banco de dados, √© lan√ßada a exce√ß√£o personalizada
                            <code>ResourceNotFoundException</code>, retornando um status HTTP 404. Faremos a
                            implementa√ß√£o dessa exce√ß√£o personalizada na pr√≥xima se√ß√£o.</li>
                    </ul>
                </li>
                <li>
                    <p><strong>Uso do <code>Map&lt;String, String&gt;</code>:</strong> </p>
                    <ul>
                        <li>O corpo da requisi√ß√£o √© recebido como um <code>Map</code>, onde: <ul>
                                <li>A chave (<code>key</code>) √© o nome do atributo a ser modificado (<code>nome</code>,
                                    <code>telefone</code> ou <code>email</code>). </li>
                                <li>O valor (<code>value</code>) √© o novo valor que ser√° atribu√≠do ao atributo
                                    correspondente.</li>
                            </ul>
                        </li>
                        <li>Esse formato √© √∫til porque permite que a requisi√ß√£o inclua <strong>somente os campos que
                                precisam ser atualizados</strong>, sem exigir o envio do objeto completo.</li>
                    </ul>
                </li>
                <li>
                    <p><strong>Itera√ß√£o sobre o <code>Map</code>:</strong> </p>
                    <ul>
                        <li>A fun√ß√£o <code>updates.forEach()</code> percorre cada entrada (<code>key</code>,
                            <code>value</code>) do <code>Map</code>. </li>
                        <li>A estrutura <code>switch</code> verifica qual campo deve ser atualizado e o modifica
                            chamando os m√©todos <code>setNome()</code>, <code>setTelefone()</code> ou
                            <code>setEmail()</code> do objeto <code>Contact</code>.</li>
                    </ul>
                </li>
                <li>
                    <p><strong>Persist√™ncia dos Dados:</strong> </p>
                    <ul>
                        <li>Ap√≥s atualizar os campos necess√°rios, o m√©todo chama
                            <code>contactRepository.save(contact)</code> para salvar as modifica√ß√µes no banco de dados.
                        </li>
                        <li>O objeto atualizado √© retornado como resposta.</li>
                    </ul>
                </li>
            </ol>
            <h3>üìå <strong>2.2 Exemplo de Requisi√ß√£o:</strong></h3>
            <p>Suponha que temos um contato com o ID <code>1</code>, e desejamos atualizar apenas o email desse contato.
                A requisi√ß√£o ficaria assim:</p>
            <pre><code>PATCH /api/contacts/1
Content-Type: application/json

{
    &quot;email&quot;: &quot;novocontato@email.com&quot;
}
</code></pre>
            <p>Tamb√©m √© poss√≠vel enviar m√∫ltiplos campos para serem atualizados ao mesmo tempo:</p>
            <pre><code>PATCH /api/contacts/1
Content-Type: application/json

{
    &quot;nome&quot;: &quot;Jo√£o Silva&quot;,
    &quot;telefone&quot;: &quot;99998888&quot;
}
</code></pre>
            <h2><strong>2.3 üîç Como o m√©todo est√° relacionado ao tratamento de erros?</strong></h2>
            <p>Caso o ID do contato submetido na requisi√ß√£o n√£o seja encontrado, o m√©todo lan√ßa uma exce√ß√£o
                <code>ResourceNotFoundException</code>:</p>
            <pre><code class="language-java">Contact contact = contactRepository.findById(id)
        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
</code></pre>
            <p>Essa exce√ß√£o √© capturada por outra classe que iremos criar: a <code>GlobalExceptionHandler</code>,
                configurada para retornar uma resposta com c√≥digo <strong>HTTP 404 (Not Found)</strong> quando ocorrer
                um <code>ResourceNotFoundException</code>, garantindo que o cliente receba uma mensagem clara sobre o
                problema ocorrido. Antes de passarmos √† cri√ß√£o dessas duas classes, entretanto, vamos entender
                brevemente o uso do <code>orElseThrow()</code> com <strong>Lambda Expression</strong>.</p>
            <p>O m√©todo Faz parte da l√≥gica que busca um contato no banco de dados pelo seu ID, como vimos anteriormente
                quando abordamos as <strong>Naming Conventions</strong>. <code>findById()</code> √© fornecido pela
                interface <code>JpaRepository</code> (que <code>ContactRepository</code> estende) e retorna um objeto do
                tipo <code>Optional&lt;Contact&gt;</code>.</p>
            <pre><code class="language-java">Optional&lt;Contact&gt; findById(Long id);
</code></pre>
            <p>Nesse caso o uso do <code>Optional</code> √© importante porque permite que o m√©todo retorne um valor
                presente (o contato encontrado) ou ausente (<code>Optional.empty()</code>) se o ID n√£o existir no banco
                de dados. O Optional √© uma classe introduzida no Java 8, que faz parte do pacote <code>java.util</code>.
                Ele foi criado para lidar com o problema comum de <code>NullPointerException</code>, proporcionando uma
                maneira elegante de representar a presen√ßa ou aus√™ncia de um valor: em vez de retornar um valor
                potencialmente nulo, m√©todos podem retornar um Optional, que √© um cont√™iner que pode ou n√£o conter um
                valor n√£o-nulo. Para saber mais, consulte a <a
                    href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Documenta√ß√£o Oficial do
                    Optional (Java 8)</a>.</p>
            <p>Para extrair o valor contido no <code>Optional</code>, utilizamos o m√©todo <code>orElseThrow()</code>,
                que √© uma forma pr√°tica e segura de lidar com poss√≠veis aus√™ncias de valor.</p>
            <h3><strong>2.4 üìå O que √© <code>orElseThrow()</code>?</strong></h3>
            <p>O m√©todo <code>orElseThrow()</code> √© um m√©todo da classe <code>Optional&lt;T&gt;</code> que √© utilizado
                para:</p>
            <ul>
                <li><strong>Retornar o valor contido no <code>Optional</code></strong> se ele estiver presente.</li>
                <li><strong>Lan√ßar uma exce√ß√£o personalizada</strong> caso o valor n√£o esteja presente.</li>
            </ul>
            <p>O m√©todo <code>orElseThrow()</code> recebe um <strong>Supplier</strong> como argumento. Um
                <code>Supplier</code> √© uma interface funcional que n√£o recebe par√¢metros e retorna um objeto
                (<code>T</code>). Ele √© frequentemente implementado usando <strong>Express√µes Lambda</strong>, que
                tornam o c√≥digo mais enxuto e leg√≠vel.</p>
            <p>A express√£o lambda usada aqui √©:</p>
            <pre><code class="language-java">() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id)
</code></pre>
            <ul>
                <li>Os par√™nteses <code>()</code> indicam que a fun√ß√£o lambda <strong>n√£o recebe par√¢metros</strong>.
                </li>
                <li>A seta <code>-&gt;</code> indica o in√≠cio da parte execut√°vel da express√£o lambda. </li>
                <li>A parte <code>new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id)</code> √© o
                    c√≥digo executado quando o lambda √© invocado. </li>
                <li>Neste caso, estamos retornando uma nova inst√¢ncia de <code>ResourceNotFoundException</code>.</li>
            </ul>
            <h4><strong>2.5 üìå Por que usar uma Express√£o Lambda aqui?</strong></h4>
            <p>O m√©todo <code>orElseThrow()</code> exige um argumento que implemente a interface
                <code>Supplier</code>.<br>Se n√£o utiliz√°ssemos uma express√£o lambda, a declara√ß√£o seria mais verbosa,
                algo como:</p>
            <pre><code class="language-java">Contact contact = contactRepository.findById(id)
        .orElseThrow(new Supplier&lt;ResourceNotFoundException&gt;() {
            @Override
            public ResourceNotFoundException get() {
                return new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id);
            }
        });
</code></pre>
            <p>Claramente, a forma lambda √© <strong>muito mais compacta e leg√≠vel</strong>.</p>
            <h3><strong>2.6 üìå Ou seja...</strong></h3>
            <pre><code class="language-java">Contact contact = contactRepository.findById(id)
        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
</code></pre>
            <ul>
                <li>Tenta buscar um <code>Contact</code> pelo <code>id</code> fornecido.</li>
                <li>Se encontrado, retorna o objeto <code>Contact</code>.</li>
                <li>Se n√£o encontrado, lan√ßa uma exce√ß√£o <code>ResourceNotFoundException</code> com a mensagem
                    personalizada.</li>
                <li>A exce√ß√£o √© tratada pelo <code>GlobalExceptionHandler</code> e retorna o status HTTP 404 para o
                    cliente.</li>
            </ul>
            <p>Agora que entendemos essa linha de c√≥digo, vamos abordar o uso de Exceptions customizadas e a
                implementa√ß√£o de nosso <code>GlobalExceptionHandler</code>.</p>
            <h3><strong>2.7 Tratamento de Erros Relacionados ao M√©todo PATCH</strong></h3>
            <p>O tratamento de exce√ß√µes na API √© feito pela classe <code>GlobalExceptionHandler</code>, que lida com
                diferentes tipos de erros, incluindo a <code>ResourceNotFoundException</code>. O tratamento de erros √©
                uma parte essencial de uma API REST bem estruturada. Ele garante que os consumidores da API recebam
                mensagens claras e adequadas sobre o que ocorreu, al√©m de evitar a exposi√ß√£o de detalhes internos do
                sistema.</p>
            <p>No nosso projeto, utilizamos uma classe chamada <code>GlobalExceptionHandler</code> anotada com
                <code>@RestControllerAdvice</code>. Essa classe intercepta exce√ß√µes lan√ßadas em qualquer parte da
                aplica√ß√£o e retorna uma resposta adequada para o cliente. Para manter a organiza√ß√£o do c√≥digo vamos
                criar um pacote <strong>exception</strong>, a fim de manter uma estrutura clara e direta.</p>
            <h3><strong>2.8 üìå Implementa√ß√£o inicial da Classe <code>GlobalExceptionHandler</code></strong></h3>
            <pre><code class="language-java">package br.ifsp.contacts.exception;

@RestControllerAdvice
public class GlobalExceptionHandler {
    /**
     * Trata exce√ß√µes de recurso n√£o encontrado
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleResourceNotFoundException(ResourceNotFoundException exception) {
        Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();
        errorResponse.put(&quot;error&quot;, exception.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }

    /**
     * Trata exce√ß√µes gen√©ricas que n√£o foram capturadas pelos handlers anteriores.
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleGenericException(Exception exception) {
        Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();
        errorResponse.put(&quot;error&quot;, &quot;Erro interno no servidor. Entre em contato com o suporte.&quot;);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}
</code></pre>
            <h3><strong>2.9 üîç Como funciona?</strong></h3>
            <ol>
                <li>Os m√©todos s√£o anotados com <code>@ExceptionHandler</code> para especificar quais tipos de exce√ß√£o
                    devem ser capturados. Ou seja, cada m√©todo ser√° chamado quando ocorrer o tipo de exce√ß√£o para o qual
                    ele est√° anotado (<code>ResourceNotFoundException.class</code>, <code>Exception.class</code> e assim
                    por diante).</li>
                <li>A anota√ß√£o <code>@RestControllerAdvice</code> faz com que a classe capture exce√ß√µes lan√ßadas por
                    qualquer controlador da nossa aplica√ß√£o.</li>
                <li>Os m√©todos retornam um <code>ResponseEntity</code>, uma classe do Spring que permite personalizar
                    completamente a resposta HTTP, incluindo o corpo da mensagem, o status HTTP e os cabe√ßalhos. Isso
                    proporciona maior controle sobre o que √© retornado ao cliente, garantindo que respostas adequadas
                    sejam enviadas para diferentes situa√ß√µes, como sucessos, erros ou requisi√ß√µes inv√°lidas.</li>
                <li><code>ResourceNotFoundException</code> √© uma exce√ß√£o customizada que retorna um c√≥digo HTTP 404.
                    Vamos definir essa classe a seguir.</li>
            </ol>
            <h3><strong>2.10 üìå Classe <code>ResourceNotFoundException</code></strong></h3>
            <pre><code class="language-java">package br.ifsp.contacts.exception;

public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String message) {
        super(message);
    }
}
</code></pre>
            <p>Essa classe √© uma exce√ß√£o customizada que herda de <code>RuntimeException</code>. Ela √© utilizada para
                indicar que um recurso solicitado (por exemplo, um contato que o usu√°rio est√° tentando acessar) n√£o foi
                encontrado no banco de dados. A garantia de que essa exce√ß√£o resultar√° em uma resposta HTTP com c√≥digo
                <strong>404 (Not Found)</strong> ocorre porque o <strong>GlobalExceptionHandler</strong> possui um
                m√©todo anotado com <code>@ExceptionHandler(ResourceNotFoundException.class)</code>. Essa anota√ß√£o
                instrui o Spring a interceptar qualquer exce√ß√£o do tipo <code>ResourceNotFoundException</code> lan√ßada
                pela aplica√ß√£o e tratar essa exce√ß√£o de maneira centralizada, como explicado acima.</p>
            <p>O que acontece aqui √© o seguinte:</p>
            <ol>
                <li><strong>Intercepta√ß√£o da Exce√ß√£o:</strong> Sempre que uma <code>ResourceNotFoundException</code> √©
                    lan√ßada em qualquer parte da aplica√ß√£o, o m√©todo <code>handleResourceNotFoundException()</code> √©
                    chamado automaticamente. </li>
                <li><strong>Personaliza√ß√£o da Resposta:</strong> O m√©todo cria um <code>ResponseEntity</code> com um
                    corpo JSON contendo a mensagem de erro e define explicitamente o c√≥digo de status HTTP como
                    <code>404 (Not Found)</code>. </li>
                <li><strong>Anota√ß√£o <code>@ResponseStatus</code>:</strong> Embora o c√≥digo HTTP j√° seja definido pelo
                    <code>ResponseEntity</code> (<code>HttpStatus.NOT_FOUND</code>), a anota√ß√£o
                    <code>@ResponseStatus(HttpStatus.NOT_FOUND)</code> fornece uma camada extra de garantia que o status
                    apropriado ser√° retornado.</li>
            </ol>
            <p>Portanto, a garantia se d√° pelo mecanismo centralizado do Spring para captura e tratamento de exce√ß√µes,
                configurado pelo <code>@ExceptionHandler</code> no <code>GlobalExceptionHandler</code>.</p>
            <h3><strong>2.10 üéØ Em resumo...</strong></h3>
            <p>Quando o m√©todo <code>updateContactPartial</code> utiliza <code>contactRepository.findById()</code>, ele
                lan√ßa a exce√ß√£o <code>ResourceNotFoundException</code> se o ID n√£o existir. Essa exce√ß√£o √© tratada pelo
                m√©todo <code>handleResourceNotFoundException</code> no <code>GlobalExceptionHandler</code>, retornando
                uma resposta com o c√≥digo HTTP <strong>404 - Not Found</strong>.</p>
            <p>O tratamento de erros bem estruturado evita que o cliente receba informa√ß√µes internas da aplica√ß√£o e
                padroniza as mensagens de erro. A integra√ß√£o do <code>GlobalExceptionHandler</code> √© essencial para
                capturar exce√ß√µes lan√ßadas pelo m√©todo PATCH e devolver respostas amig√°veis.</p>
            <p>Devemos sempre fazer tratamento de erros na nossa aplica√ß√£o, especialmente em APIs REST que precisam
                fornecer respostas claras e adequadas para os clientes que as consomem. Podemos citar os seguintes
                motivadores para isso:</p>
            <ul>
                <li>
                    <ol>
                        <li><strong>Melhoria na Experi√™ncia do Usu√°rio:</strong> Um tratamento adequado de erros garante
                            que o cliente receba mensagens √∫teis e compreens√≠veis, em vez de mensagens gen√©ricas ou
                            c√≥digos de status que n√£o explicam o problema.</li>
                    </ol>
                </li>
                <li>
                    <ol start="2">
                        <li><strong>Seguran√ßa:</strong> Se erros n√£o forem tratados corretamente, informa√ß√µes sens√≠veis
                            sobre a aplica√ß√£o podem ser expostas acidentalmente, como detalhes do banco de dados ou da
                            l√≥gica de neg√≥cio.</li>
                    </ol>
                </li>
                <li>
                    <ol start="3">
                        <li><strong>Facilidade na Depura√ß√£o:</strong> Mensagens de erro claras e espec√≠ficas facilitam a
                            identifica√ß√£o e corre√ß√£o de problemas, tanto durante o desenvolvimento quanto na manuten√ß√£o
                            da aplica√ß√£o.</li>
                    </ol>
                </li>
                <li>
                    <ol start="4">
                        <li><strong>Conformidade com os Padr√µes REST:</strong> APIs bem projetadas devem retornar
                            c√≥digos HTTP apropriados (<code>404</code> para recurso n√£o encontrado, <code>400</code>
                            para requisi√ß√£o inv√°lida, <code>500</code> para erro interno, etc.) e fornecer informa√ß√µes
                            √∫teis sobre o problema.</li>
                    </ol>
                </li>
                <li>
                    <ol start="5">
                        <li><strong>Evitar Que a Aplica√ß√£o Quebre:</strong> Tratamento adequado de erros impede que a
                            aplica√ß√£o seja interrompida inesperadamente por uma exce√ß√£o n√£o tratada.</li>
                    </ol>
                </li>
            </ul>
            <h4><strong>2.11 üö© O que acontece se n√£o tratarmos erros adequadamente?</strong></h4>
            <ul>
                <li>A aplica√ß√£o pode retornar mensagens gen√©ricas ou c√≥digos HTTP inadequados, dificultando a depura√ß√£o.
                </li>
                <li>Pode expor informa√ß√µes sens√≠veis que deveriam permanecer ocultas. </li>
                <li>Pode quebrar a aplica√ß√£o se uma exce√ß√£o cr√≠tica n√£o for tratada. </li>
                <li>Pode resultar em m√° experi√™ncia para os usu√°rios e desenvolvedores que consomem a API.</li>
            </ul>
            <p>Embora o tratamento de erros n√£o seja obrigat√≥rio para que a aplica√ß√£o funcione, ele √© essencial para
                garantir <strong>seguran√ßa, clareza, padroniza√ß√£o e uma melhor experi√™ncia para os usu√°rios e
                    desenvolvedores</strong>. Portanto, √© considerado <strong>uma boa pr√°tica fundamental em qualquer
                    aplica√ß√£o</strong>. </p>
            <p>O nosso <code>GlobalExceptionHandler</code> entretanto ainda n√£o est√° pronto. Brevemente vamos voltar a
                inserir novos tratamentos na classe. Antes disso, entretanto, vamos explorar os Desafios 1 e 2 da Aula
                03 e os conceitos que envolvem o relacionamento e valida√ß√£o de Entidades.</p>
            <hr>
            <h2><strong>3.üîç Criando e validando modelos de Dados</strong></h2>
            <p>Para continuarmos a abordar os conceitos do desenvolvimento de APIS Rest com Spring Boot, relembremos os
                Desafios 1 e 2 da Aula 03.</p>
            <p>O Desafio 1 tinha como objetivo criar uma nova entidade <code>Address</code> relacionada
                bidirecionalmente com <code>Contact</code>, implementar um reposit√≥rio <code>AddressRepository</code> e
                criar um controlador <code>AddressController</code> para gerenciar endere√ßos. Tamb√©m era necess√°rio
                criar um endpoint <code>GET /api/contacts/{id}/addresses</code> para listar todos os endere√ßos
                associados a um contato espec√≠fico.</p>
            <p>J√° o Desafio 2 exigia a adi√ß√£o de valida√ß√µes na entidade <code>Contact</code> utilizando a anota√ß√£o
                <code>@Valid</code>. As regras incluem: nome n√£o pode estar vazio, email deve ter um formato v√°lido
                (<code>@Email</code>) e telefone deve ter entre 8 e 15 caracteres. A API deve retornar respostas
                adequadas para entradas inv√°lidas.</p>
            <p>Para facilitar a explica√ß√£o e evitar repeti√ß√£o desnecess√°rio, vamos implementar c√≥digo que atenda ambos
                os desafios. Para conseguir implementar esses desafios, entretanto, temos que entender dois conceitos
                fundamentais: relacionamento entre Entidades com uso da JPA e a Valida√ß√£o de dados com a
                <code>Jakarta Bean Validation</code>.</p>
            <h3><strong>3.1 Uma breve introdu√ß√£o ao relacionamento entre Entidades</strong></h3>
            <p>Relacionamentos de entidades na JPA s√£o fundamentais para representar como os dados interagem entre si no
                banco de dados. A JPA (Java Persistence API) fornece suporte para mapeamento de associa√ß√µes entre
                entidades usando anota√ß√µes espec√≠ficas que permitem definir os tipos de relacionamento que podem ocorrer
                entre essas entidades. Os relacionamentos mais comuns s√£o OneToOne, OneToMany, ManyToOne e ManyToMany.
                Quando mapeamos uma rela√ß√£o <strong>OneToOne</strong>, indicamos que uma entidade est√° associada
                exclusivamente a outra entidade. Para isso, utilizamos a anota√ß√£o <code>@OneToOne</code>, que pode ser
                configurada com o atributo <code>mappedBy</code> para especificar o lado propriet√°rio da rela√ß√£o.</p>
            <p>No relacionamento <strong>ManyToOne</strong>, uma entidade pode estar associada a v√°rias inst√¢ncias de
                outra entidade, mas a rela√ß√£o inversa geralmente √© <strong>OneToMany</strong>, ou seja, um √∫nico objeto
                de uma entidade pode ter v√°rias refer√™ncias de outra entidade. Por exemplo, em uma aplica√ß√£o de contatos
                e endere√ßos, cada endere√ßo est√° associado a um √∫nico contato, mas um contato pode ter m√∫ltiplos
                endere√ßos. Isso √© representado na JPA com <code>@ManyToOne</code> na classe <code>Address</code> e
                <code>@OneToMany</code> na classe <code>Contact</code>. Al√©m disso, √© necess√°rio configurar
                adequadamente as anota√ß√µes <code>@JoinColumn</code> para definir a chave estrangeira que conecta as
                tabelas.</p>
            <p>O relacionamento <strong>ManyToMany</strong> √© usado quando m√∫ltiplas inst√¢ncias de uma entidade podem
                estar associadas a m√∫ltiplas inst√¢ncias de outra. Esse tipo de relacionamento geralmente √© mapeado por
                meio de uma tabela intermedi√°ria que cont√©m as chaves estrangeiras de ambas as entidades relacionadas.
                Na JPA, usamos a anota√ß√£o <code>@ManyToMany</code> para definir esse tipo de relacionamento, e podemos
                usar a propriedade <code>mappedBy</code> para especificar o lado n√£o propriet√°rio da associa√ß√£o.</p>
            <p>√â importante entender que os relacionamentos na JPA podem ser configurados para serem unidirecionais ou
                bidirecionais. Uma associa√ß√£o unidirecional significa que apenas uma entidade conhece a exist√™ncia da
                outra, enquanto uma associa√ß√£o bidirecional permite que ambas as entidades se conhe√ßam mutuamente, o que
                √© √∫til quando queremos acessar dados relacionados de forma mais natural e eficiente. Quando
                implementamos um relacionamento bidirecional, precisamos garantir que a sincroniza√ß√£o entre os dois
                lados do relacionamento seja tratada adequadamente. Isso √© feito configurando o atributo
                <code>mappedBy</code> no lado que n√£o √© o propriet√°rio da rela√ß√£o, informando √† JPA qual entidade √©
                respons√°vel pelo gerenciamento do relacionamento.</p>
            <p>Al√©m disso, ao configurar relacionamentos, √© fundamental definir adequadamente o comportamento de
                <strong>cascade</strong> e <strong>orphanRemoval</strong>, que especificam se opera√ß√µes realizadas em
                uma entidade principal devem ser propagadas para as entidades relacionadas. Por exemplo, ao excluir um
                contato, podemos querer que todos os endere√ßos associados tamb√©m sejam removidos automaticamente, o que
                √© configurado com o uso da propriedade <code>cascade = CascadeType.ALL</code> e
                <code>orphanRemoval = true</code> na anota√ß√£o <code>@OneToMany</code>.</p>
            <h3><strong>3.2 Valida√ß√£o de dados de forma simplificada</strong></h3>
            <p>A valida√ß√£o de dados √© um processo essencial para garantir que as informa√ß√µes fornecidas por usu√°rios ou
                sistemas externos sejam corretas, seguras e adequadas antes de serem processadas ou armazenadas. A
                linguagem Java fornece v√°rias maneiras de realizar valida√ß√µes, mas a abordagem mais comum e eficiente √©
                por meio das anota√ß√µes de valida√ß√£o fornecidas pelo pacote <strong>Jakarta Bean Validation</strong>
                (anteriormente conhecido como Java EE Bean Validation) e integrado ao Spring Framework por meio da
                biblioteca <strong>Hibernate Validator</strong>. Esse mecanismo oferece uma maneira declarativa e
                robusta para validar dados de entrada sem necessidade de escrever c√≥digo complexo para cada regra de
                valida√ß√£o.</p>
            <p>O Jakarta Bean Validation utiliza anota√ß√µes que s√£o aplicadas diretamente sobre os atributos das classes,
                facilitando o processo de valida√ß√£o e mantendo o c√≥digo organizado e leg√≠vel. As anota√ß√µes mais comuns
                incluem <code>@NotNull</code>, que garante que o valor de um campo n√£o pode ser nulo;
                <code>@NotBlank</code>, que assegura que um campo de texto n√£o √© vazio ou apenas cont√©m espa√ßos em
                branco; <code>@Size</code>, que define o tamanho m√≠nimo e m√°ximo permitido para uma string ou cole√ß√£o;
                <code>@Pattern</code>, que permite especificar uma express√£o regular para valida√ß√£o de formato; e
                <code>@Email</code>, que verifica se um dado fornecido corresponde a um formato v√°lido de endere√ßo de
                e-mail. Al√©m dessas, existem v√°rias outras anota√ß√µes espec√≠ficas que podem ser usadas dependendo das
                necessidades da aplica√ß√£o, podendo ser consultadas em <a
                    href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-spec">Hibernate
                    Validator - Defini√ß√£o de Restri√ß√µes (Documenta√ß√£o Oficial)</a></p>
            <p>A configura√ß√£o da valida√ß√£o no Spring Boot √© bastante simples e, geralmente, basta adicionar a
                depend√™ncia do <code>Hibernate Validator</code> no arquivo <code>pom.xml</code> do projeto. </p>
            <p>Ao longo da disciplina vamos, evidentemente, utilizar as valida√ß√µes para o desenvolvimento de APIs com o
                Spring Boot. Nesse contexto, o uso da anota√ß√£o <code>@Valid</code> nos controladores REST √© fundamental
                para ativar o mecanismo de valida√ß√£o autom√°tica dos dados recebidos. Quando um cliente envia dados para
                o servidor, o Spring automaticamente verifica se os dados atendem aos crit√©rios estabelecidos pelas
                anota√ß√µes de valida√ß√£o na entidade ou no DTO (Data Transfer Object, padr√£o que abordaremos nas pr√≥ximas
                aulas) e, caso algum crit√©rio n√£o seja satisfeito, uma exce√ß√£o √© lan√ßada, normalmente a
                <code>MethodArgumentNotValidException</code>. Essa exce√ß√£o precisa ser tratada por um mecanismo de
                tratamento de erros personalizado, como o <code>GlobalExceptionHandler</code> que implementamos
                anteriormente, para que a aplica√ß√£o possa responder de forma adequada e amig√°vel ao cliente, geralmente
                retornando um c√≥digo de status HTTP 400 (Bad Request) junto com uma mensagem explicativa. Ou seja, a
                partir da√≠ basta aplicar as anota√ß√µes necess√°rias nos atributos das entidades ou DTOs e n√£o se esquecer
                utilizar o <code>@Valid</code> nos m√©todos controladores. Al√©m disso, o Spring Boot permite definir
                mensagens de erro personalizadas para cada tipo de valida√ß√£o, tornando as respostas da API mais claras e
                amig√°veis para os consumidores do servi√ßo.</p>
            <p>Al√©m das valida√ß√µes padr√£o fornecidas pela especifica√ß√£o Jakarta Bean Validation, √© poss√≠vel definir
                valida√ß√µes personalizadas quando os requisitos do sistema s√£o mais espec√≠ficos. Para isso, criamos uma
                anota√ß√£o customizada e implementamos um validador que implementa a interface
                <code>ConstraintValidator</code>. Esse mecanismo permite que os desenvolvedores criem suas pr√≥prias
                regras de valida√ß√£o e as apliquem a campos ou classes inteiras, mantendo a flexibilidade e a
                escalabilidade da aplica√ß√£o. Futuramente exploraremos essa possibilidade na disciplina.</p>
            <p>√â importante destacar que a valida√ß√£o de dados deve ser realizada tanto no lado do cliente quanto no lado
                do servidor. Embora bibliotecas de frontend como React e Angular forne√ßam recursos para valida√ß√£o de
                formul√°rios, a valida√ß√£o no servidor √© indispens√°vel para garantir a seguran√ßa e integridade dos dados,
                pois os clientes podem ser manipulados ou burlados por usu√°rios mal-intencionados. Por isso, as
                valida√ß√µes feitas no servidor s√£o a principal linha de defesa contra dados inv√°lidos ou maliciosos.
                <strong>Lembrem-se: temos controle real apenas sobre o lado do servidor. O lado cliente √© do
                    cliente!</strong></p>
            <p>Vamos agora verificar o c√≥digo que implementa os Desafios 1 e 2 da Aula 03.</p>
            <hr>
            <h2><strong>üîç4. An√°lise dos C√≥digos-fontes</strong></h2>
            <p>Passemos, agora, a an√°lise dos c√≥digos que implementam os Desafios 1 e 2. Para fins de brevidade e
                objetividade da explica√ß√£o, apresentaremos todos em sequ√™ncia. </p>
            <ul>
                <li>Caso exista algum erro de c√≥digo-fonte abaixo, avise ao professor! Todas as corre√ß√µes pertinentes
                    ser√£o incorporadas!</li>
            </ul>
            <h3><strong>4.1 ‚úÖC√≥digo da Entidade <code>Address</code></strong></h3>
            <p>A classe <code>Address</code> foi implementada abaixo com os atributos e valida√ß√µes necess√°rias, de forma
                a atender os Desafios 1 e 2. Vamos analisar o c√≥digo:</p>
            <pre><code class="language-java">@Entity
public class Address {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = &quot;A rua n√£o pode estar vazia&quot;)
    private String rua;

    @NotBlank(message = &quot;A cidade n√£o pode estar vazia&quot;)
    private String cidade;

    @NotBlank(message = &quot;O estado n√£o pode estar vazio&quot;)
    @Size(min = 2, max = 2, message = &quot;O estado deve ter exatamente 2 caracteres (sigla)&quot;)
    @Pattern(regexp = &quot;[A-Z]{2}&quot;, message = &quot;O estado deve ser representado por duas letras mai√∫sculas&quot;)
    private String estado;

    @NotBlank(message = &quot;O CEP n√£o pode estar vazio&quot;)
    @Pattern(regexp = &quot;\\d{5}-\\d{3}&quot;, message = &quot;O CEP deve estar no formato 99999-999&quot;)
    private String cep;

    @ManyToOne
    @JoinColumn(name = &quot;contact_id&quot;, nullable = false)
    @JsonBackReference
    private Contact contact;
}
</code></pre>
            <h3><strong>üîçAnalisando o c√≥digo</strong></h3>
            <ul>
                <li>A classe define os atributos exigidos: <code>rua</code>, <code>cidade</code>, <code>estado</code>,
                    <code>cep</code> e a rela√ß√£o com o <code>Contact</code>.</li>
                <li>Utiliza anota√ß√µes de valida√ß√£o (<code>@NotBlank</code>, <code>@Size</code>, <code>@Pattern</code>)
                    para garantir que os dados sejam v√°lidos antes de serem persistidos.</li>
                <li>A anota√ß√£o <code>@ManyToOne</code> define a rela√ß√£o com a classe <code>Contact</code>, com a coluna
                    <code>contact_id</code> no banco de dados.</li>
                <li>A anota√ß√£o <code>@JsonBackReference</code> √© usada para evitar problemas de refer√™ncia c√≠clica ao
                    serializar os objetos (<code>Contact</code> e <code>Address</code>) para JSON. Quando uma entidade
                    possui uma cole√ß√£o de entidades relacionadas, como acontece em rela√ß√µes <code>OneToMany</code>, √©
                    necess√°rio indicar que a serializa√ß√£o de JSON deve ignorar a refer√™ncia de volta para o propriet√°rio
                    da rela√ß√£o. Dessa forma, evitamos erros como <code>StackOverflowException</code> quando a convers√£o
                    para JSON √© realizada.</li>
            </ul>
            <p>Al√©m disso, percebam que por enquanto vamos transitar diretamente a entidade entre as diferentes camadas
                da aplica√ß√£o, inclusive expondo dados como o ID das entidades para o client. √â por isso tamb√©m que temos
                que usar as anota√ß√µes para evitar problemas de serializa√ß√£o. A solu√ß√£o para isso seria implementar
                <strong>DTOs (Data Transfer Objects)</strong>. DTOs s√£o classes criadas para transportar dados entre
                diferentes camadas da aplica√ß√£o. Quando implementamos DTOs estamos essencialmente <strong>separando a
                    representa√ß√£o de dados da API (o que √© retornado ou recebido pelo cliente) da modelagem interna da
                    nossa aplica√ß√£o</strong> (as entidades JPA que manipulam o banco de dados). Os DTOs s√£o classes que
                cont√™m apenas os dados que voc√™ quer expor na API, sem manter rela√ß√µes direcionais ou bidirecionais
                presentes nas entidades.</p>
            <p>Essa abordagem √© melhor por alguns motivos:</p>
            <ol>
                <li>Permite a <strong>Independ√™ncia da camada de persist√™ncia</strong>, onde o que √© exposto na API n√£o
                    precisa ter o mesmo formato do banco de dados.</li>
                <li><strong>Evita problemas de serializa√ß√£o c√≠clica:</strong> As entidades JPA podem manter suas
                    rela√ß√µes bidirecionais, mas o Jackson s√≥ ver√° os DTOs.</li>
                <li><strong>Seguran√ßa:</strong> Permite controlar exatamente o que √© exposto ao cliente, sem expor dados
                    sens√≠veis ou desnecess√°rios.</li>
                <li><strong>Flexibilidade:</strong> Facilita a evolu√ß√£o da API sem alterar diretamente a estrutura das
                    entidades no banco de dados.</li>
            </ol>
            <p>Na pr√≥xima aula faremos essa melhoria no c√≥digo, mas por enquanto basta que fiquem cientes que a
                abordagem adotada at√© aqui √© a mais did√°tica, s√≥ que n√£o necessariamente a mais adequada.</p>
            <p>Evidentemente, tamb√©m devemos atualizar a classe Contact. A implementa√ß√£o completa pode ser vista a
                seguir.</p>
            <h3><strong>4.2 ‚úÖC√≥digo atualizado da Entidade <code>Contact</code></strong></h3>
            <pre><code class="language-java">
package br.ifsp.contacts.model;

@Entity
public class Contact {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = &quot;O nome n√£o pode estar vazio&quot;)
    private String nome;
    
    @NotBlank(message = &quot;O email n√£o pode estar vazio&quot;)
    @Email(message = &quot;Formato de email inv√°lido&quot;)
    private String email;
    
    @NotBlank(message = &quot;O telefone n√£o pode estar vazio&quot;)
    @Size(min = 8, max = 15, message = &quot;O telefone deve ter entre 8 e 15 caracteres&quot;)
    @Pattern(regexp = &quot;\\d+&quot;, message = &quot;O telefone deve conter apenas n√∫meros&quot;)
    private String telefone;
    
    @OneToMany(mappedBy = &quot;contact&quot;, cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    @NotEmpty(message = &quot;O contato deve ter pelo menos um endere√ßo&quot;)
    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();
    
    public Contact() {
    }
    
    public Contact(String nome, String email, String telefone) {
        this.nome = nome;
        this.email = email;
        this.telefone = telefone;
    }
    
    public Long getId() {
        return id;
    }
    
    public String getNome() {
        return nome;
    }
    
    public void setNome(String nome) {
        this.nome = nome;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getTelefone() {
        return telefone;
    }
    
    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }
    
    public List&lt;Address&gt; getAddresses() {
        return addresses;
    }
    
    public void setAddresses(List&lt;Address&gt; addresses) {
        if (addresses != null) {
            addresses.forEach(address -&gt; address.setContact(this)); 
            
            if (this.addresses == null) { 
                this.addresses = new ArrayList&lt;&gt;();
            }
            
            this.addresses.clear(); 
            this.addresses.addAll(addresses);         
        }
    }
}
</code></pre>
            <h3><strong>üîçAnalisando o c√≥digo</strong></h3>
            <p>A classe <code>Contact</code> √© uma entidade JPA que representa um <strong>contato</strong> na aplica√ß√£o
                e est√° mapeada para uma tabela no banco de dados por meio da anota√ß√£o <code>@Entity</code>. Esta classe
                cont√©m diversos atributos, incluindo uma lista de endere√ßos (<code>List&lt;Address&gt; addresses</code>)
                que se relaciona diretamente com a entidade <code>Address</code>. A seguir, vamos detalhar cada parte da
                classe e como ela se relaciona com a classe <code>Address</code>.</p>
            <h3>üîç <strong>Atributos da Classe <code>Contact</code></strong></h3>
            <ul>
                <li><code>id</code>: √â o identificador √∫nico do contato (<code>Long</code>) e √© gerado automaticamente
                    pelo banco de dados atrav√©s da anota√ß√£o
                    <code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code>.</li>
                <li><code>nome</code>: Nome do contato, com valida√ß√£o para garantir que n√£o seja vazio
                    (<code>@NotBlank</code>).</li>
                <li><code>email</code>: Endere√ßo de email do contato, validado tanto para n√£o ser vazio
                    (<code>@NotBlank</code>) quanto para ter um formato v√°lido (<code>@Email</code>).</li>
                <li><code>telefone</code>: N√∫mero de telefone do contato, validado para ter entre 8 e 15 caracteres
                    (<code>@Size</code>), apenas n√∫meros (<code>@Pattern</code>), e n√£o ser vazio
                    (<code>@NotBlank</code>).</li>
                <li><code>addresses</code>: √â uma lista de endere√ßos (<code>Address</code>) associados a este contato.
                    Essa rela√ß√£o √© estabelecida por meio de uma associa√ß√£o <strong>OneToMany</strong>.</li>
            </ul>
            <p>O relacionamento entre <code>Contact</code> e <code>Address</code> √© <strong>bidirecional</strong> e
                configurado com as anota√ß√µes <code>@OneToMany</code> na classe <code>Contact</code> e
                <code>@ManyToOne</code> na classe <code>Address</code>, como visto na se√ß√£o anterior. Vamos ver
                detalhamente o mapeamento, que √© feito da seguinte maneira:</p>
            <h4>üìå <strong>Na Classe <code>Contact</code> (Dono do relacionamento):</strong></h4>
            <pre><code class="language-java">@OneToMany(mappedBy = &quot;contact&quot;, cascade = CascadeType.ALL, orphanRemoval = true)
@JsonManagedReference
@NotEmpty(message = &quot;O contato deve ter pelo menos um endere√ßo&quot;)
private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();
</code></pre>
            <ul>
                <li><code>@OneToMany</code>: Define que um contato pode ter v√°rios endere√ßos.</li>
                <li><code>mappedBy = &quot;contact&quot;</code>: Indica que o relacionamento √© mapeado pelo atributo
                    <code>contact</code> na classe <code>Address</code>.</li>
                <li><code>cascade = CascadeType.ALL</code>: Propaga todas as opera√ß√µes (persist√™ncia, remo√ß√£o,
                    atualiza√ß√£o) feitas na entidade <code>Contact</code> para os seus endere√ßos relacionados.</li>
                <li><code>orphanRemoval = true</code>: Remove automaticamente os endere√ßos que s√£o removidos da lista
                    <code>addresses</code>.</li>
                <li><code>@JsonManagedReference</code>: Trabalha junto com <code>@JsonBackReference</code> na classe
                    <code>Address</code> para evitar problemas de serializa√ß√£o c√≠clica (loop infinito) quando os objetos
                    s√£o convertidos para JSON.</li>
                <li><code>@NotEmpty</code>: Garante que o contato sempre tenha pelo menos um endere√ßo associado. Esse
                    tipo de valida√ß√£o garante que cada contato deve ser salvo com pelo menos um endere√ßo v√°lido,
                    evitando registros incompletos.</li>
            </ul>
            <p>√â importante notar que o m√©todo <code>setAddresses()</code> √© implementado de forma a garantir que todos
                os endere√ßos associados a este contato estejam sincronizados. Observe o trecho a seguir:</p>
            <pre><code class="language-java">public void setAddresses(List&lt;Address&gt; addresses) {
    if (addresses != null) {
        addresses.forEach(address -&gt; address.setContact(this)); 
        
        if (this.addresses == null) { 
            this.addresses = new ArrayList&lt;&gt;();
        }
        
        this.addresses.clear(); 
        this.addresses.addAll(addresses);         
    }
}
</code></pre>
            <p>Este m√©todo faz o seguinte:</p>
            <ol>
                <li><strong>Associa o contato atual a todos os endere√ßos recebidos na lista:</strong> Para cada endere√ßo
                    fornecido, o m√©todo <code>address.setContact(this)</code> √© chamado para garantir que o
                    relacionamento bidirecional seja atualizado.</li>
                <li><strong>Inicializa a lista de endere√ßos se for nula:</strong> Garante que a lista nunca ser√°
                    manipulada sem ser inicializada.</li>
                <li><strong>Limpa a lista de endere√ßos atual:</strong> Evita duplica√ß√£o de dados e garante que a lista
                    de endere√ßos seja atualizada completamente.</li>
                <li><strong>Adiciona todos os endere√ßos novos:</strong> Depois de limpar a lista, os novos endere√ßos s√£o
                    adicionados, mantendo a consist√™ncia.</li>
            </ol>
            <p>A partir das duas entidades acima, temos o relacionamento completo. Caso tiv√©ssemos mais entidades e
                regras de neg√≥cio mais complexas, a ideia se manteria a mesma: as validar√≠amos e relacionar√≠amos
                conforme a necessidade se apresentasse.</p>
            <p>Passemos agora √† an√°lise da nossa classe <code>AddressRepository</code>.</p>
            <h3><strong>4.3 ‚úÖReposit√≥rio <code>AddressRepository</code></strong></h3>
            <p>O reposit√≥rio foi implementado de forma simples. Vamos conferir:</p>
            <pre><code class="language-java">@Repository
public interface AddressRepository extends JpaRepository&lt;Address, Long&gt; {
    List&lt;Address&gt; findByContactId(Long contactId);
}
</code></pre>
            <ul>
                <li>A interface estende <code>JpaRepository&lt;Address, Long&gt;</code>, o que significa que herda todos
                    os m√©todos b√°sicos de manipula√ß√£o (<code>save()</code>, <code>delete()</code>,
                    <code>findById()</code>, etc.).</li>
                <li>O m√©todo <code>findByContactId(Long contactId)</code> √© adicionado para recuperar endere√ßos
                    associados a um contato espec√≠fico.</li>
                <li>A conven√ß√£o de nomes usada (<code>findByContactId</code>) √© suficiente para que o Spring Data JPA
                    crie a consulta SQL apropriada automaticamente.</li>
            </ul>
            <p>Ou seja: at√© aqui, nenhuma novidade na cria√ß√£o do Reposit√≥rio! Vamos verificar agora como ficaram nossos
                controladores.</p>
            <h3><strong>4.4 ‚úÖController <code>AddressController</code></strong></h3>
            <p>A classe <code>AddressController</code> √© um controlador REST respons√°vel por manipular requisi√ß√µes HTTP
                relacionadas √† entidade <code>Address</code> na aplica√ß√£o. Ela √© anotada com
                <code>@RestController</code>, o que indica que seus m√©todos retornar√£o dados diretamente no corpo da
                resposta (em formato JSON, por exemplo). Al√©m disso, a anota√ß√£o
                <code>@RequestMapping(&quot;/api/addresses&quot;)</code> define o caminho base para todos os endpoints
                dentro deste controlador. Vejamos o c√≥digo abaixo.</p>
            <pre><code class="language-java">package br.ifsp.contacts.controller;

@RestController
@RequestMapping(&quot;/api/addresses&quot;)
public class AddressController {
    
    @Autowired
    private ContactRepository contactRepository;

    @Autowired
    private AddressRepository addressRepository;
    
    @GetMapping(&quot;/contacts/{contactId}&quot;)
    public List&lt;Address&gt; getAddressesByContact(@PathVariable Long contactId) {
        Contact contact = contactRepository.findById(contactId)
                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + contactId));
        
        return contact.getAddresses();
    }
    
    @PostMapping(&quot;/contacts/{contactId}&quot;)
    @ResponseStatus(HttpStatus.CREATED)
    public Address createAddress(@PathVariable Long contactId, @RequestBody @Valid Address address) {
        Contact contact = contactRepository.findById(contactId)
                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + contactId));
        
        address.setContact(contact);
        return addressRepository.save(address);
    }
}
</code></pre>
            <h3>üîç <strong>Analisando o c√≥digo:</strong></h3>
            <h3>üìå <strong>Inje√ß√£o de Depend√™ncias (<code>@Autowired</code>)</strong></h3>
            <p>A classe utiliza inje√ß√£o de depend√™ncias para acessar os reposit√≥rios <code>ContactRepository</code> e
                <code>AddressRepository</code>, que s√£o necess√°rios para buscar contatos existentes e salvar novos
                endere√ßos. Essa inje√ß√£o √© feita automaticamente pelo Spring por meio da anota√ß√£o
                <code>@Autowired</code>, como j√° vimos anteriormente. Nas pr√≥ximas aulas vamos explorar tamb√©m a inje√ß√£o
                de depend√™ncias por meio do m√©todo construtor, que √© a alternativa mais recomendada pelos
                desenvolvedores do Spring.</p>
            <h3>üìå <strong>M√©todo <code>getAddressesByContact()</code></strong></h3>
            <pre><code class="language-java">@GetMapping(&quot;/contacts/{contactId}&quot;)
public List&lt;Address&gt; getAddressesByContact(@PathVariable Long contactId) {
    Contact contact = contactRepository.findById(contactId)
            .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + contactId));
    
    return contact.getAddresses();
}
</code></pre>
            <p>Esse m√©todo √© um endpoint <code>GET</code> que permite recuperar todos os endere√ßos associados a um
                contato espec√≠fico. Ele √© acess√≠vel por meio da URL:</p>
            <pre><code>GET /api/addresses/contacts/{contactId}
</code></pre>
            <p><strong>O que acontece nesse m√©todo:</strong> </p>
            <ol>
                <li>O m√©todo recebe um <code>contactId</code> como par√¢metro de URL e o busca no banco de dados usando o
                    <code>contactRepository.findById()</code> que retorna um <code>Optional&lt;Contact&gt;</code>.</li>
                <li>Se o contato n√£o for encontrado, o m√©todo <code>orElseThrow()</code> lan√ßa uma exce√ß√£o
                    <code>ResourceNotFoundException</code>, que √© tratada pelo <code>GlobalExceptionHandler</code> e
                    resulta em um retorno com c√≥digo HTTP 404 (Not Found).</li>
                <li>Caso o contato seja encontrado, o m√©todo retorna a lista de endere√ßos associados ao contato por meio
                    do m√©todo <code>contact.getAddresses()</code>. </li>
                <li>A resposta retornada √© uma lista de objetos <code>Address</code> convertida automaticamente para
                    JSON pelo Jackson. Esse passo √© transparente ao usarmos o Spring Boot.</li>
            </ol>
            <h3>üìå <strong>M√©todo <code>createAddress()</code></strong></h3>
            <pre><code class="language-java">@PostMapping(&quot;/contacts/{contactId}&quot;)
@ResponseStatus(HttpStatus.CREATED)
public Address createAddress(@PathVariable Long contactId, @RequestBody @Valid Address address) {
    Contact contact = contactRepository.findById(contactId)
            .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + contactId));
    
    address.setContact(contact);
    return addressRepository.save(address);
}
</code></pre>
            <p>Esse m√©todo √© um endpoint <code>POST</code> que permite criar um novo endere√ßo e associ√°-lo a um contato
                existente. Ele √© acess√≠vel por meio da URL:</p>
            <pre><code>POST /api/addresses/contacts/{contactId}
</code></pre>
            <p><strong>O que acontece nesse m√©todo:</strong> </p>
            <ol>
                <li>O m√©todo recebe um <code>contactId</code> como par√¢metro de URL e um objeto <code>Address</code>
                    como corpo da requisi√ß√£o (<code>@RequestBody</code>).</li>
                <li>A anota√ß√£o <code>@Valid</code> √© usada para garantir que o endere√ßo enviado atende a todas as regras
                    de valida√ß√£o definidas na classe <code>Address</code>.</li>
                <li>O controlador busca o contato correspondente ao <code>contactId</code> usando
                    <code>contactRepository.findById()</code>. Caso n√£o seja encontrado, √© lan√ßada uma exce√ß√£o
                    <code>ResourceNotFoundException</code>.</li>
                <li>Se o contato for encontrado, o endere√ßo √© associado ao contato usando o m√©todo
                    <code>address.setContact(contact)</code>.</li>
                <li>O endere√ßo √© salvo no banco de dados pelo <code>addressRepository.save(address)</code>.</li>
                <li>A anota√ß√£o <code>@ResponseStatus(HttpStatus.CREATED)</code> indica que, se o endere√ßo for salvo com
                    sucesso, o servidor retornar√° um c√≥digo HTTP 201 (Created).</li>
            </ol>
            <h3><strong>Em resumo...</strong></h3>
            <p>A classe <code>AddressController</code> foi implementada utilizando os conceitos j√° vistos previamente.
                Vejamos agora como ficou o c√≥digo atualizado do nosso <code>ContactController</code>.</p>
            <h3>‚úÖ <strong>4.4 Controller <code>ContactController</code></strong></h3>
            <p>A classe <code>ContactController</code> √© um <strong>controlador REST</strong>, respons√°vel por fornecer
                os endpoints para manipula√ß√£o de recursos <code>Contact</code>. Ela √© anotada com
                <code>@RestController</code>, o que indica que seus m√©todos retornam dados diretamente como respostas
                HTTP, geralmente em formato JSON. A anota√ß√£o <code>@RequestMapping(&quot;/api/contacts&quot;)</code>
                define a URL base para todos os endpoints do controlador.</p>
            <p>O controlador utiliza inje√ß√£o de depend√™ncia para receber um objeto do tipo
                <code>ContactRepository</code>, que √© respons√°vel por realizar opera√ß√µes de acesso a dados relacionadas
                aos contatos (CRUD). Essa inje√ß√£o √© feita automaticamente pelo Spring por meio da anota√ß√£o
                <code>@Autowired</code>, assim como na classe <code>AddressController</code>.</p>
            <p>Vejamos, abaixo, seu c√≥digo-fonte.</p>
            <pre><code class="language-java">package br.ifsp.contacts.controller;

@RestController
@RequestMapping(&quot;/api/contacts&quot;)
@Validated
public class ContactController {

    @Autowired
    private ContactRepository contactRepository;

    @GetMapping
    public List&lt;Contact&gt; getAllContacts() {
        return contactRepository.findAll();
    }

    @GetMapping(&quot;{id}&quot;)
    public Contact getContactById(@PathVariable Long id) {
        return contactRepository.findById(id)
                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Contact createContact(@Valid @RequestBody Contact contact) {
        return contactRepository.save(contact);
    }

    @PutMapping(&quot;/{id}&quot;)
    public Contact updateContact(@PathVariable Long id, @Valid @RequestBody Contact updatedContact) {
        Contact existingContact = contactRepository.findById(id)
                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

        existingContact.setNome(updatedContact.getNome());
        existingContact.setEmail(updatedContact.getEmail());
        existingContact.setTelefone(updatedContact.getTelefone());
        existingContact.setAddresses(updatedContact.getAddresses());

        return contactRepository.save(existingContact);
    }

    @PatchMapping(&quot;/{id}&quot;)
    public Contact updateContactPartial(@PathVariable Long id, @RequestBody Map&lt;String, String&gt; updates) {
        Contact contact = contactRepository.findById(id)
                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Contato n√£o encontrado: &quot; + id));

        updates.forEach((key, value) -&gt; {
            switch (key) {
                case &quot;nome&quot;:
                    contact.setNome(value);
                    break;
                case &quot;telefone&quot;:
                    contact.setTelefone(value);
                    break;
                case &quot;email&quot;:
                    contact.setEmail(value);
                    break;
            }
        });

        return contactRepository.save(contact);
    }

    @DeleteMapping(&quot;/{id}&quot;)
    public void deleteContact(@PathVariable Long id) {
        contactRepository.deleteById(id);
    }

    @GetMapping(&quot;/search&quot;)
    public List&lt;Contact&gt; searchContactsByName(@RequestParam String name) {
        return contactRepository.findByNomeContainingIgnoreCase(name);
    }
}
</code></pre>
            <h3>üìå <strong>M√©todos Implementados no Controller</strong></h3>
            <p>O controlador <code>ContactController</code> oferece m√©todos CRUD e um m√©todo adicional para busca
                personalizada. Vamos detalh√°-los:</p>
            <h4>‚úÖ <code>getAllContacts()</code></h4>
            <pre><code class="language-java">@GetMapping
public List&lt;Contact&gt; getAllContacts() {
    return contactRepository.findAll();
}
</code></pre>
            <p>Este m√©todo retorna todos os contatos presentes no banco de dados. √â um endpoint <code>GET</code>
                acess√≠vel por:</p>
            <pre><code>GET /api/contacts
</code></pre>
            <p>A resposta √© uma lista de objetos <code>Contact</code>.</p>
            <h4>‚úÖ <code>getContactById()</code></h4>
            <pre><code class="language-java">@GetMapping(&quot;{id}&quot;)
public Contact getContactById(@PathVariable Long id)
</code></pre>
            <p>Esse m√©todo busca um contato espec√≠fico por seu <code>id</code>. Ele retorna um erro
                <code>404 - Not Found</code> caso o contato n√£o exista, usando o m√©todo <code>orElseThrow()</code> que
                lan√ßa a exce√ß√£o <code>ResourceNotFoundException</code>. √â acess√≠vel por:</p>
            <pre><code>GET /api/contacts/{id}
</code></pre>
            <p>Se encontrado, retorna o objeto <code>Contact</code> correspondente.</p>
            <h4>‚úÖ <code>createContact()</code></h4>
            <pre><code class="language-java">@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Contact createContact(@Valid @RequestBody Contact contact)
</code></pre>
            <p>Esse m√©todo cria um novo contato a partir dos dados enviados no corpo da requisi√ß√£o. A anota√ß√£o
                <code>@Valid</code> garante que as valida√ß√µes definidas na classe <code>Contact</code> sejam
                respeitadas. √â acess√≠vel por:</p>
            <pre><code>POST /api/contacts
</code></pre>
            <p>Se o contato for criado com sucesso, retorna o objeto <code>Contact</code> salvo no banco de dados com o
                c√≥digo <code>201 - Created</code>.</p>
            <h4>‚úÖ <code>updateContact()</code></h4>
            <pre><code class="language-java">@PutMapping(&quot;/{id}&quot;)
public Contact updateContact(@PathVariable Long id, @Valid @RequestBody Contact updatedContact)
</code></pre>
            <p>Esse m√©todo atualiza todos os dados de um contato existente identificado pelo <code>id</code>. Caso o
                contato n√£o seja encontrado, √© lan√ßada uma <code>ResourceNotFoundException</code>. A atualiza√ß√£o √© feita
                de forma completa, substituindo os dados antigos pelos novos. √â acess√≠vel por:</p>
            <pre><code>PUT /api/contacts/{id}
</code></pre>
            <p>Retorna o contato atualizado.</p>
            <h4>‚úÖ <code>updateContactPartial()</code></h4>
            <pre><code class="language-java">@PatchMapping(&quot;/{id}&quot;)
public Contact updateContactPartial(@PathVariable Long id, @RequestBody Map&lt;String, String&gt; updates)
</code></pre>
            <p>Este m√©todo permite atualiza√ß√µes <strong>parciais</strong> em um contato. Ele recebe um mapa
                (<code>Map&lt;String, String&gt;</code>) contendo os campos que devem ser atualizados e seus novos
                valores. Somente os campos presentes no mapa s√£o modificados; os demais permanecem inalterados. √â
                acess√≠vel por:</p>
            <pre><code>PATCH /api/contacts/{id}
</code></pre>
            <p>Caso o contato n√£o seja encontrado, lan√ßa uma <code>ResourceNotFoundException</code>.</p>
            <h4>‚úÖ <code>deleteContact()</code></h4>
            <pre><code class="language-java">@DeleteMapping(&quot;/{id}&quot;)
public void deleteContact(@PathVariable Long id)
</code></pre>
            <p>Esse m√©todo exclui um contato identificado por seu <code>id</code>. A exclus√£o √© feita por meio do m√©todo
                <code>deleteById()</code> do <code>ContactRepository</code>. Se o contato n√£o existir, o reposit√≥rio n√£o
                realiza nenhuma a√ß√£o. √â acess√≠vel por:</p>
            <pre><code>DELETE /api/contacts/{id}
</code></pre>
            <p>Retorna uma resposta sem conte√∫do (<code>204 - No Content</code>) se a exclus√£o for bem-sucedida.</p>
            <h4>‚úÖ <code>searchContactsByName()</code></h4>
            <pre><code class="language-java">@GetMapping(&quot;/search&quot;)
public List&lt;Contact&gt; searchContactsByName(@RequestParam String name)
</code></pre>
            <p>Esse m√©todo realiza uma <strong>busca personalizada</strong> por nome. Ele utiliza o m√©todo
                <code>findByNomeContainingIgnoreCase()</code> do <code>ContactRepository</code> para encontrar contatos
                cujo nome contenha o termo pesquisado, independentemente de mai√∫sculas ou min√∫sculas. √â acess√≠vel por:
            </p>
            <pre><code>GET /api/contacts/search?name=Joao
</code></pre>
            <p>Retorna uma lista de contatos que correspondem ao crit√©rio de busca.</p>
            <h3>üìå <strong>Como os m√©todos interagem com a camada de persist√™ncia
                    (<code>ContactRepository</code>)?</strong></h3>
            <p>O controlador depende diretamente do reposit√≥rio <code>ContactRepository</code> para todas as opera√ß√µes
                de leitura, escrita, atualiza√ß√£o e exclus√£o. A camada de persist√™ncia √© configurada para lidar com
                entidades JPA (<code>Contact</code>), o que significa que as opera√ß√µes de banco de dados s√£o tratadas de
                forma transparente pelo Spring Data JPA. √â a mesm√≠ssima coisa que j√° fizemos anteriormente. Percebam:
                estamos apenas repetindo os mesmos padr√µes j√° vistos anteriormente.</p>
            <h3>üìå <strong>Como os m√©todos tratam erros e valida√ß√µes?</strong></h3>
            <ul>
                <li><strong>Valida√ß√£o de Dados:</strong> A anota√ß√£o <code>@Valid</code> garante que os objetos enviados
                    na requisi√ß√£o atendam √†s regras definidas na classe <code>Contact</code>.</li>
                <li><strong>Tratamento de Erros:</strong> O uso de <code>ResourceNotFoundException</code> integrado com
                    o <code>GlobalExceptionHandler</code> garante que as requisi√ß√µes inv√°lidas sejam respondidas de
                    forma apropriada (<code>404 - Not Found</code>).</li>
            </ul>
            <p>√â exatamente a mesma l√≥gica que aplicamos no <code>AddressController</code>!</p>
            <h3>‚úÖ <strong>4.5 Melhorando o <code>GlobalExceptionHandler</code></strong></h3>
            <p>A implementa√ß√£o inicial do <code>GlobalExceptionHandler</code> foi projetada para lidar apenas com
                exce√ß√µes gen√©ricas (<code>Exception</code>) e com uma exce√ß√£o personalizada espec√≠fica
                (<code>ResourceNotFoundException</code>). Essa abordagem j√° proporcionava uma maneira centralizada e
                padronizada de tratar erros na aplica√ß√£o. No entanto, ela carecia de um tratamento mais robusto para
                situa√ß√µes comuns no desenvolvimento de APIs REST, especialmente em rela√ß√£o √† valida√ß√£o de dados de
                entrada.</p>
            <p>A implementa√ß√£o inicial era limitada porque: </p>
            <ul>
                <li>Tratava apenas exce√ß√µes gen√©ricas (<code>Exception</code>) e <code>ResourceNotFoundException</code>.
                </li>
                <li>N√£o possu√≠a suporte para o tratamento expl√≠cito de erros de valida√ß√£o.</li>
                <li>N√£o fornecia mensagens detalhadas sobre quais campos espec√≠ficos estavam inv√°lidos, o que poderia
                    dificultar a compreens√£o por parte do cliente da API.</li>
            </ul>
            <p>Podemos melhorar a implementa√ß√£o inicial, mostrada na se√ß√£o 2.8, por meio do c√≥digo-fonte abaixo</p>
            <pre><code class="language-java">package br.ifsp.contacts.exception;

import jakarta.validation.ConstraintViolationException;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * Trata erros de valida√ß√£o de entrada (ex: campos inv√°lidos no @Valid)
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException exception) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        exception.getBindingResult().getAllErrors().forEach((error) -&gt; {
            if (error instanceof FieldError) {
                String fieldName = ((FieldError) error).getField();
                String errorMessage = error.getDefaultMessage();
                errors.put(fieldName, errorMessage);
            }
        });
        return ResponseEntity.badRequest().body(errors);
    }
    
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleGlobalValidationExceptions(ConstraintViolationException  exception) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        exception.getConstraintViolations().forEach(violation -&gt; 
            errors.put(violation.getPropertyPath().toString(), violation.getMessage())
        );
        return ResponseEntity.badRequest().body(errors);
    }
    
    /**
     * Trata exce√ß√µes de recurso n√£o encontrado
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleResourceNotFoundException(ResourceNotFoundException exception) {
        Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();
        errorResponse.put(&quot;error&quot;, exception.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
    
    /**
     * Trata exce√ß√µes gen√©ricas que n√£o foram capturadas pelos handlers anteriores.
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleGenericException(Exception exception) {
        Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();
        errorResponse.put(&quot;error&quot;, &quot;Erro interno no servidor. Entre em contato com o suporte.&quot;);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
    
}
</code></pre>
            <h3>üìå <strong>O que foi melhorado na implementa√ß√£o final?</strong></h3>
            <p>Essa implementa√ß√£o melhorada do <code>GlobalExceptionHandler</code> amplia significativamente o escopo de
                tratamento de erros ao adicionar suporte para exce√ß√µes de valida√ß√£o. Isso foi feito adicionando m√©todos
                espec√≠ficos para capturar e processar erros relacionados √† entrada de dados inv√°lida. Vamos analisar as
                melhorias implementadas.</p>
            <h3>üìå <strong>Suporte a <code>MethodArgumentNotValidException</code></strong></h3>
            <p>O m√©todo <code>handleValidationExceptions()</code> foi adicionado para tratar exce√ß√µes do tipo
                <code>MethodArgumentNotValidException</code>. Essas exce√ß√µes s√£o lan√ßadas quando um objeto validado com
                a anota√ß√£o <code>@Valid</code> n√£o atende √†s regras definidas nas entidades, como
                <code>@NotBlank</code>, <code>@Size</code>, <code>@Pattern</code>, etc.</p>
            <pre><code class="language-java">@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException exception) {
    Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
    exception.getBindingResult().getAllErrors().forEach((error) -&gt; {
        if (error instanceof FieldError) {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        }
    });
    return ResponseEntity.badRequest().body(errors);
}
</code></pre>
            <ul>
                <li>Este m√©todo percorre todos os erros encontrados e os mapeia para um objeto <code>Map</code> que
                    associa o nome do campo (<code>fieldName</code>) com a mensagem de erro (<code>errorMessage</code>).
                </li>
                <li>A resposta gerada √© uma <code>ResponseEntity</code> contendo um <code>Map</code> que detalha todos
                    os erros detectados, retornando o status HTTP <code>400 (Bad Request)</code>.</li>
                <li>Essa implementa√ß√£o melhora a experi√™ncia do usu√°rio, fornecendo feedback claro sobre o que precisa
                    ser corrigido.</li>
            </ul>
            <h3>üìå <strong>Suporte a <code>ConstraintViolationException</code></strong></h3>
            <p>O m√©todo <code>handleGlobalValidationExceptions()</code> foi adicionado para capturar exce√ß√µes do tipo
                <code>ConstraintViolationException</code>. Essas exce√ß√µes geralmente ocorrem quando se tenta validar
                dados em controladores que n√£o recebem objetos completos, mas par√¢metros individuais, por exemplo, ao
                utilizar <code>@RequestParam</code> ou <code>@PathVariable</code> com valida√ß√µes <code>@Valid</code>.
            </p>
            <pre><code class="language-java">@ExceptionHandler(ConstraintViolationException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleGlobalValidationExceptions(ConstraintViolationException exception) {
    Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
    exception.getConstraintViolations().forEach(violation -&gt; 
        errors.put(violation.getPropertyPath().toString(), violation.getMessage())
    );
    return ResponseEntity.badRequest().body(errors);
}
</code></pre>
            <ul>
                <li>Este m√©todo percorre todas as viola√ß√µes detectadas (<code>constraintViolations</code>) e as armazena
                    em um <code>Map</code>.</li>
                <li>A resposta HTTP retornada √© <code>400 (Bad Request)</code>, apropriada para requisi√ß√µes inv√°lidas.
                </li>
                <li>Este tratamento √© √∫til para capturar erros em par√¢metros simples, como um telefone inv√°lido passado
                    diretamente na URL.</li>
            </ul>
            <h3>üìå <strong>Tratamento Gen√©rico para Outras Exce√ß√µes</strong></h3>
            <p>O m√©todo <code>handleGenericException()</code> √© um fallback para qualquer exce√ß√£o que n√£o foi capturada
                por m√©todos mais espec√≠ficos.</p>
            <pre><code class="language-java">@ExceptionHandler(Exception.class)
@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleGenericException(Exception exception) {
    Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();
    errorResponse.put(&quot;error&quot;, &quot;Erro interno no servidor. Entre em contato com o suporte.&quot;);
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
}
</code></pre>
            <ul>
                <li>A captura gen√©rica de exce√ß√µes garante que erros inesperados sejam tratados com uma resposta padr√£o.
                </li>
                <li>Retorna o status HTTP <code>500 (Internal Server Error)</code>, indicando um problema do lado do
                    servidor.</li>
            </ul>
            <p>Com isso, temos uma maior cobertura √† valida√ß√£o na nossa aplica√ß√£o, cobrindo todos os casos especificados
                nos Desafios e Exerc√≠cios at√© o momento!</p>
            <hr>
            <h2>5. Estrutura do Projeto e testes ap√≥s a implementa√ß√£o dos exerc√≠cios e desafios</h2>
            <p>Ap√≥s a implementa√ß√£o das classes acima, nossa estrutura de pacotes ficou da seguinte forma:</p>
            <pre><code>.
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ main
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ br
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ifsp
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ contacts
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ ContactsApplication.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ controller
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ AddressController.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ ContactController.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ model
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ Address.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ Contact.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ repository
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ AddressRepository.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îÇ   ‚îî‚îÄ‚îÄ ContactRepository.java
‚îÇ   ‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ exception
‚îÇ   ‚îÇ   ‚îÇ                   ‚îî‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îÇ   ‚îÇ                   ‚îî‚îÄ‚îÄ ResourceNotFoundException.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ application.properties
‚îÇ   ‚îî‚îÄ‚îÄ test
‚îÇ       ‚îî‚îÄ‚îÄ java
‚îî‚îÄ‚îÄ pom.xml (ou build.gradle)
</code></pre>
            <p>Vamos ver agora como testar nossa API para garantir que todas as funcionalidades implementadas est√£o
                funcionando corretamente! </p>
            <h2>üìå <strong>Teste 1: Criar um Contato (<code>POST /api/contacts</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>POST</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts</code></li>
                <li><strong>Body (JSON):</strong></li>
            </ol>
            <pre><code class="language-json">{
  &quot;nome&quot;: &quot;Jo√£o Silva&quot;,
  &quot;email&quot;: &quot;joao.silva@email.com&quot;,
  &quot;telefone&quot;: &quot;11999999999&quot;,
  &quot;addresses&quot;: [
    {
      &quot;rua&quot;: &quot;Rua A&quot;,
      &quot;cidade&quot;: &quot;S√£o Paulo&quot;,
      &quot;estado&quot;: &quot;SP&quot;,
      &quot;cep&quot;: &quot;12345-678&quot;
    }
  ]
}
</code></pre>
            <ol start="4">
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>201 - Created</code></li>
                        <li>Resposta com o contato criado, incluindo o endere√ßo associado.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 2: Listar Todos os Contatos (<code>GET /api/contacts</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>GET</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts</code></li>
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>200 - OK</code></li>
                        <li>Resposta com a lista de contatos criados, incluindo seus endere√ßos.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 3: Buscar Contato por ID (<code>GET /api/contacts/{id}</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>GET</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts/1</code> (Substitua o <code>1</code>
                    pelo ID do contato que voc√™ deseja consultar)</li>
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>200 - OK</code></li>
                        <li>Retorno do contato correspondente ao ID especificado.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 4: Atualiza√ß√£o Parcial de Contato (<code>PATCH /api/contacts/{id}</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>PATCH</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts/1</code> (Substitua o <code>1</code>
                    pelo ID do contato que voc√™ deseja atualizar)</li>
                <li><strong>Body (JSON):</strong></li>
            </ol>
            <pre><code class="language-json">{
  &quot;nome&quot;: &quot;Jo√£o Silva Jr.&quot;,
  &quot;telefone&quot;: &quot;11988888888&quot;
}
</code></pre>
            <ol start="4">
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>200 - OK</code></li>
                        <li>Retorno do contato atualizado, refletindo as altera√ß√µes enviadas.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 5: Criar um Endere√ßo para um Contato
                    (<code>POST /api/addresses/contacts/{contactId}</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>POST</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/addresses/contacts/1</code> (Substitua o
                    <code>1</code> pelo ID do contato que voc√™ deseja associar o endere√ßo)</li>
                <li><strong>Body (JSON):</strong></li>
            </ol>
            <pre><code class="language-json">{
  &quot;rua&quot;: &quot;Rua B&quot;,
  &quot;cidade&quot;: &quot;Rio de Janeiro&quot;,
  &quot;estado&quot;: &quot;RJ&quot;,
  &quot;cep&quot;: &quot;22222-222&quot;
}
</code></pre>
            <ol start="4">
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>201 - Created</code></li>
                        <li>O endere√ßo deve ser salvo e associado ao contato especificado.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 6: Listar Endere√ßos de um Contato
                    (<code>GET /api/addresses/contacts/{contactId}</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>GET</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/addresses/contacts/1</code></li>
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>200 - OK</code></li>
                        <li>Lista dos endere√ßos associados ao contato especificado.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 7: Buscar Contatos por Nome (<code>GET /api/contacts/search?name=Joao</code>)</strong>
            </h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>GET</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts/search?name=Joao</code></li>
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>200 - OK</code></li>
                        <li>Retorna uma lista de contatos cujos nomes correspondem parcial ou totalmente ao termo
                            pesquisado.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 8: Exclus√£o de Contato (<code>DELETE /api/contacts/{id}</code>)</strong></h2>
            <p>No Postman ou Insomnia:</p>
            <ol>
                <li><strong>M√©todo:</strong> <code>DELETE</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts/1</code></li>
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>204 - No Content</code></li>
                        <li>O contato √© exclu√≠do permanentemente do banco de dados.</li>
                    </ul>
                </li>
            </ol>
            <h2>üìå <strong>Teste 9: Teste de Valida√ß√£o (<code>POST /api/contacts</code>)</strong></h2>
            <p>Vamos verificar se as valida√ß√µes da entidade <code>Contact</code> funcionam corretamente. </p>
            <ol>
                <li><strong>M√©todo:</strong> <code>POST</code></li>
                <li><strong>URL:</strong> <code>http://localhost:8080/api/contacts</code></li>
                <li><strong>Body (JSON):</strong></li>
            </ol>
            <pre><code class="language-json">{
  &quot;nome&quot;: &quot;&quot;,
  &quot;email&quot;: &quot;invalidEmail&quot;,
  &quot;telefone&quot;: &quot;123&quot;,
  &quot;addresses&quot;: []
}
</code></pre>
            <ol start="4">
                <li><strong>Resultado Esperado:</strong>
                    <ul>
                        <li>C√≥digo HTTP <code>400 - Bad Request</code></li>
                        <li>Mensagens de erro indicando o que est√° inv√°lido:</li>
                    </ul>
                </li>
            </ol>
            <pre><code class="language-json">{
  &quot;nome&quot;: &quot;O nome n√£o pode estar vazio&quot;,
  &quot;email&quot;: &quot;Formato de email inv√°lido&quot;,
  &quot;telefone&quot;: &quot;O telefone deve ter entre 8 e 15 caracteres&quot;,
  &quot;addresses&quot;: &quot;O contato deve ter pelo menos um endere√ßo&quot;
}
</code></pre>
            <hr>
            <h2><strong>6. Recapitulando!</strong></h2>
            <p>Nesta aula, aprimoramos a nossa API REST desenvolvida na aula anterior, implementando novos recursos e
                adotando boas pr√°ticas essenciais para garantir a robustez e a consist√™ncia da aplica√ß√£o. Abordamos
                conceitos como <strong>consultas customizadas no JPA</strong> utilizando conven√ß√µes de nomes e queries
                personalizadas por meio da anota√ß√£o <code>@Query</code>. Implementamos m√©todos PATCH para atualiza√ß√µes
                parciais de recursos, utilizando o tipo <code>Map&lt;String, String&gt;</code> e garantindo que apenas
                os campos especificados sejam modificados, mantendo os demais intactos.</p>
            <p>O tratamento de erros foi aprimorado com a implementa√ß√£o de um <code>GlobalExceptionHandler</code>, que
                captura e trata exce√ß√µes espec√≠ficas, como <code>ResourceNotFoundException</code>, garantindo respostas
                HTTP adequadas e amig√°veis. Exploramos a import√¢ncia do tratamento de erros para garantir seguran√ßa,
                clareza, padroniza√ß√£o e uma melhor experi√™ncia do usu√°rio.</p>
            <p>Al√©m disso, trabalhamos com <strong>relacionamentos de entidades usando JPA</strong>, implementando uma
                rela√ß√£o bidirecional <code>OneToMany / ManyToOne</code> entre <code>Contact</code> e
                <code>Address</code>. Tamb√©m introduzimos conceitos de <strong>valida√ß√£o de dados</strong> utilizando a
                <code>Jakarta Bean Validation</code> para garantir que os dados fornecidos pelos clientes sejam v√°lidos
                antes de serem processados pela aplica√ß√£o.</p>
            <p>Por fim, implementamos controladores REST (<code>ContactController</code> e
                <code>AddressController</code>) para manipula√ß√£o dessas entidades, expondo endpoints que permitem criar,
                recuperar, atualizar e excluir contatos e seus respectivos endere√ßos. </p>
            <p>Al√©m disso, mencionamos que a forma implementada atualmente √© did√°tica, por√©m pode ser aprimorada.
                Fizemos uma breve introdu√ß√£o ao conceito de DTOs, o que nos leva aos...</p>
            <hr>
            <h2><strong>7. Exerc√≠cios ü§ì</strong></h2>
            <p><strong>1Ô∏è‚É£ - Implementa√ß√£o de DTOs (Data Transfer Objects)</strong><br>Atualmente, a API utiliza
                entidades diretamente na comunica√ß√£o entre o cliente e o servidor. Para melhorar a seguran√ßa, controle
                dos dados expostos e evitar problemas de serializa√ß√£o c√≠clica, implemente DTOs para <code>Contact</code>
                e <code>Address</code>. Substitua os objetos retornados pelos controladores por DTOs e modifique os
                controladores para aceitar DTOs como entrada. </p>
            <p><strong>2Ô∏è‚É£ - Persist√™ncia em Banco de Dados Relacional</strong><br>At√© agora, estamos utilizando o banco
                de dados em mem√≥ria configurado pelo Spring Data JPA. Altere a aplica√ß√£o para utilizar um banco de dados
                relacional real, como MySQL ou PostgreSQL. Modifique o arquivo <code>application.properties</code>
                configurando as propriedades de conex√£o, e adicione depend√™ncias adequadas no <code>pom.xml</code>.</p>
            <p><strong>3Ô∏è‚É£ - Pagina√ß√£o e Ordena√ß√£o</strong><br>Implemente pagina√ß√£o e ordena√ß√£o nos m√©todos que retornam
                listas de contatos e endere√ßos. Utilize a interface <code>Pageable</code> do Spring Data JPA e crie
                endpoints que aceitem par√¢metros de pagina√ß√£o e ordena√ß√£o na URL. Garanta que o resultado seja retornado
                de forma paginada, e n√£o como uma lista completa.</p>
            <p><strong>4Ô∏è‚É£ - Implementa√ß√£o de Documenta√ß√£o da API com Swagger</strong><br>Agora que j√° implementamos
                funcionalidades importantes na nossa API REST, √© hora de garantir que os usu√°rios da API possam
                entend√™-la e utiliz√°-la de forma adequada. Para isso, integre o Swagger, que permitir√° a gera√ß√£o
                autom√°tica de uma documenta√ß√£o interativa e amig√°vel. Adicione as depend√™ncias adequadas no
                <code>pom.xml</code>, crie uma Classe de Configura√ß√£o, documente os Endpoints e Teste a Documenta√ß√£o.
            </p>
            <h3><strong>üìå Instru√ß√µes Finais</strong></h3>
            <ul>
                <li>‚úÖ Para os exerc√≠cios <strong>pr√°ticos (1 a 4)</strong> a entrega esperada √© o c√≥digo das novas rotas
                    e prints das requisi√ß√µes no Postman ou Insomnia. <strong>Envie um link do GitHub</strong> ou um
                    arquivo <strong>.zip</strong> com o c√≥digo-fonte por meio do Moodle da disciplina.</li>
                <li>‚úÖ Para o exerc√≠cio <strong>4</strong> entregue tamb√©m prints mostrando o teste da documenta√ß√£o
                    gerada pelo swagger. Adicione os prints ao reposit√≥rio GIT ou no arquivo .zip juntamente com o
                    c√≥digo-fonte.</li>
                <li>‚úÖTeste todas as funcionalidades antes de enviar e garanta que o c√≥digo est√° funcionando.</li>
            </ul>
            <h2><strong>Bons estudos e m√£os √† obra! üõ†üî•</strong></h2>

        </div>

    </div>

    <footer class="footer mt-auto py-3">
        <div class="container-fluid">
            <span>
                <p class="text-center text-light">Instituto Federal de Educa√ß√£o, Ci√™ncia e Tecnologia de S√£o Paulo,
                    C√¢mpus
                    Guarulhos. APIs e Microsservi√ßos - Prof. Giovani.</p>
            </span>
        </div>
    </footer>
    </div>


    <script src="js/prism.js"></script>
    <script src="js/jquery.min.js"></script>
    <script src="js/popper.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/main.js"></script>

</body>

</html>